[{"title":"前端知识问答","url":"/2022/04/02/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/","content":"<h3 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h3><p><strong>link标签的行内属性 deffer和async的含义和区别</strong></p>\n<p>当script标签设置这两个行内属性后，js文件将会异步加载，不会阻塞dom的渲染。</p>\n<p>它们的区别是：defer会在endanger渲染完成后DOMContentLoaded之前按照顺序执行。而async只要加载完就会立即执行</p>\n<h3 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h3><p><strong>移动端的适配</strong></p>\n<p>参考 <a class=\"link\"   href=\"https://www.jianshu.com/p/b13d811a6a76\" >https://www.jianshu.com/p/b13d811a6a76<i class=\"fas fa-external-link-alt\"></i></a></p>\n<p><strong>sass&#x2F;less&#x2F;stylus如何实现主题切换</strong></p>\n<p>基本的思路：把不同主题的样式代码打包在一起，通过不同的主题class来实现主题切换。这个class可以加载body上或者根组件上，也可以加载到具体的元素或者更小的模块上。</p>\n<p>下面看看sass的实现</p>\n<p>首先，创建一个theme.scss文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$light&#123;</span><br><span class=\"line\">\tprimaryColor:white;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">$dark&#123;</span><br><span class=\"line\">\tprimaryColor:black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$themes:&#123;</span><br><span class=\"line\">\tlight:$light,</span><br><span class=\"line\">\tdark:$dark</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后创建一个themify.scss</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@import &#x27;./theme.scss&#x27;</span><br><span class=\"line\">@mixin themify($themes:$themes)&#123;</span><br><span class=\"line\">\t@each $them-name,$theme-map in $themes &#123;</span><br><span class=\"line\">\t\t$theme-map:$theme-map !global //局部变量提升为全局变量</span><br><span class=\"line\">\t\tbody[data-theme=#&#123;$theme-name&#125;] &amp; &#123;</span><br><span class=\"line\">\t\t\t@content;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@function themed($key)&#123;</span><br><span class=\"line\">\t@return map-get($theme-map,$key)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@import &#x27;/themify.scss&#x27;</span><br><span class=\"line\">.container&#123;</span><br><span class=\"line\">\t@include themify($themes)&#123;</span><br><span class=\"line\">\t\tcolor:themed(&#x27;primaryColor&#x27;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>实现一个三栏布局</strong></p>\n<p>三栏布局有很多种方法：利用绝对定位、浮动、bfc，flex、table等都可以实现</p>\n<p>具体可参考 <a class=\"link\"   href=\"https://zhuanlan.zhihu.com/p/25070186\" >https://zhuanlan.zhihu.com/p/25070186<i class=\"fas fa-external-link-alt\"></i></a></p>\n<p><strong>哪些css属性会自动继承，哪些不会？具体讲讲</strong></p>\n<p>字体、文本、可见性属性(opacity visibility)等大多是自动继承属性；盒子模型、背景、定位、生成内容(如content)、轮廓等一般是无继承属性。需要注意：a标签的字体颜色不能被继承，h1-h6的字体大小也不能被继承。</p>\n<p><strong>什么是bfc</strong></p>\n<p>bfc即块级格式化上下文，它会形成相对于其容器外一个独立的空间，其内部的子元素不会影响到外部的元素，同时不会和float的元素重叠。bfc可应用于防止margin坍塌、实现多栏布局、清除浮动等场景。触发bfc的条件&#x2F;属性：html、float、值不为visible的overflow、display为inline-block、table、inline-table、table-cell、table-caption、flex、inline-flex、grid、inline-grid.</p>\n<h3 id=\"javascript\"><a href=\"#javascript\" class=\"headerlink\" title=\"javascript\"></a>javascript</h3><p><strong>普通函数和箭头函数的区别</strong></p>\n<ul>\n<li>箭头函数没有arguments绑定，取而代之用rest参数…解决。但是，箭头函数可以访问最近的非箭头函数的arguments对象。</li>\n<li>箭头函数没有自己的this，它的this在生命周期中是保持不变的，始终与最近的非箭头函数中的this的值绑定。</li>\n<li>箭头函数不能作为构造函数，也就是不能被new，</li>\n<li>箭头函数不能存在重复命名的参数</li>\n<li>箭头函数没有原型属性</li>\n<li>箭头函数不能当做Generator函数，不能使用yield关键字</li>\n</ul>\n<p><strong>weakSet和weakMap的应用场景</strong></p>\n<ul>\n<li>weakSet的成员只能是对象，不能是其他类型。weakSet中的对象都是弱引用，因此垃圾回收机制不考虑weakSet对该对象的引用，如果其他对象不再引用该对象，垃圾回收机制将会自动回收该对象所占用的内存，而不考虑该对象还存在于weakSet中。使用场景：用来存储dom节点，而不用担心这些节点从文档移除会引发内存泄露。</li>\n<li>weakMap只能接受对象作为键名，不接受其他类型的值作为键名。weakMap同样不会妨碍垃圾回收机制。</li>\n<li>使用场景：在网页的dom元素上添加数据，就可以使用weakMap结构，当该dom元素被清除，其对应的weakMap记录会被自动移除。</li>\n</ul>\n<p><strong>js如何比较两个对象是否相等</strong></p>\n<p>通过遍历一层一层比较值是否相等，当前层遇到对象，则继续遍历，直到最深一层的值为基本类型。</p>\n<p><strong>es6的继承</strong></p>\n<p>extends</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// es6继承</span><br><span class=\"line\">  class Animal &#123;</span><br><span class=\"line\">    //构造函数，里面写上对象的属性</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">      this.name = props.name || &#x27;Unknown&#x27;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //方法写在后面</span><br><span class=\"line\">    eat() &#123;//父类共有的方法</span><br><span class=\"line\">      console.log(this.name + &quot; will eat pests.&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //class继承</span><br><span class=\"line\">  class Bird extends Animal &#123;</span><br><span class=\"line\">    //构造函数</span><br><span class=\"line\">    constructor(props,myAttribute) &#123;//props是继承过来的属性，myAttribute是自己的属性</span><br><span class=\"line\">      //调用实现父类的构造函数</span><br><span class=\"line\">      super(props)//相当于获得父类的this指向</span><br><span class=\"line\">      this.type = props.type || &quot;Unknown&quot;;//父类的属性，也可写在父类中</span><br><span class=\"line\">      this.attr = myAttribute;//自己的私有属性</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fly() &#123;//自己私有的方法</span><br><span class=\"line\">      console.log(this.name + &quot; are friendly to people.&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    myattr() &#123;//自己私有的方法</span><br><span class=\"line\">      console.log(this.type+&#x27;---&#x27;+this.attr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//通过new实例化</span><br><span class=\"line\">  var myBird = new Bird(&#123;</span><br><span class=\"line\">    name: &#x27;小燕子&#x27;,</span><br><span class=\"line\">    type: &#x27;Egg animal&#x27;//卵生动物</span><br><span class=\"line\">  &#125;,&#x27;Bird class&#x27;)</span><br><span class=\"line\">  myBird.eat()</span><br><span class=\"line\">  myBird.fly()</span><br><span class=\"line\">  myBird.myattr()</span><br></pre></td></tr></table></figure>\n\n<p><strong>object.assign和…拓展符的区别</strong></p>\n<p>本质上没有区别，object.assign等同于…拓展符。</p>\n<p><strong>谈谈promise</strong></p>\n<p>Promise是一种比较常用的异步编程方案。它有三种状态：</p>\n<p>pending，fulfiled，rejected，分别表示等待，完成，失败。状态的改变只有两种pending-&gt;fulfiled,pending-&gt;rejected,这个过程是不可逆的。创建一个Promise实例时需要传入一个函数，这个函数的入参分别是resolve和reject两个函数，用来修改promise的状态。执行resolve后状态为fulfiled，执行reject后状态改为rejected，举个常见的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const p1= new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">\tsetTimeout(()=&gt;&#123;</span><br><span class=\"line\">\t\tif(isGood)&#123;</span><br><span class=\"line\">\t\t\tresolve(&#x27;成功了&#x27;)</span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\treject(&#x27;失败了&#x27;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>然后通过链式调用的方式去处理状态变更后的结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">p1.then(res=&gt;&#123;dosth&#125;)</span><br><span class=\"line\">.catch(err=&gt;&#123;dosth&#125;)</span><br><span class=\"line\">.finally(data=&gt;&#123;dosth&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>Promise还提供了一些静态方法，用于做一些其他有趣的处理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Promise.all([p1,p2,p3,...])</span><br></pre></td></tr></table></figure>\n\n<p>该方法接受一个promise组成的数组,所有的promise对象都成功才会触发fulfiled，只要有一个失败就会触发rejected</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Promise.allSettled([p1,p2,p3,...])</span><br></pre></td></tr></table></figure>\n\n<p>只要所有的promise都settled(fulfiled或rejected)，返回一个promise，携带一个对象数组，每个对象对应各个promise的结果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Promise.race([p1,p2,p3,...])</span><br></pre></td></tr></table></figure>\n\n<p>返回一个promise，只要有一个promise的状态改为fulfiled或rejected，则立即触发其自身的fulfied或者rejected。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Promise.resolve(value)</span><br></pre></td></tr></table></figure>\n\n<p>返回一个状态为成功的promise对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Promise.reject(error)</span><br></pre></td></tr></table></figure>\n\n<p>返回一个状态为失败的promise对象。</p>\n<p><strong>axios请求撤销，重连</strong></p>\n<p>撤销主要是利用axios.CancelToken，axios官网介绍了两种使用方法：</p>\n<p>方法一（多用于取消单个接口）：</p>\n<p>通过传入一个执行函数到CancelToken构造函数来创建一个cancel token</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import axios from &#x27;axios&#x27;</span><br><span class=\"line\">let cancel</span><br><span class=\"line\">export function getSth()&#123;</span><br><span class=\"line\">\treturn axios(&#123;</span><br><span class=\"line\">\t\turl:&#x27;/abc&#x27;，</span><br><span class=\"line\">\t\tmethod:&#x27;get&#x27;.</span><br><span class=\"line\">\t\tcancelToken:new axios.CancelToken(funtion executor(c)&#123;</span><br><span class=\"line\">\t\t\tcancel = c</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要取消的时候，直接调用cancel即可</p>\n<p>方法二（撤销多个请求）：</p>\n<p>使用CancelToken.source工厂方法创建一个cancel token。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import axios from &#x27;axios&#x27;</span><br><span class=\"line\">const CancelToken = axios.CancelToken</span><br><span class=\"line\">const source = CancelToken.source()</span><br><span class=\"line\">export function getSth()&#123;</span><br><span class=\"line\">\treturn axios(&#123;</span><br><span class=\"line\">\t\turl:&#x27;/abc&#x27;,</span><br><span class=\"line\">\t\tmethod:&#x27;get&#x27;,</span><br><span class=\"line\">\t\tcancelToken:source.token</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>取消调用source.cancel()</p>\n<p>关于重连，即网络出现不佳或者请求失败的重新连接机制。</p>\n<p>axios的重连可通过响应拦截器来实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">request.interceptors.response.use(</span><br><span class=\"line\">\tresponse =&gt;response.data || &#123;&#125;,</span><br><span class=\"line\">\terr =&gt;&#123;</span><br><span class=\"line\">\t\tlet config = err.config</span><br><span class=\"line\">\t\tif(!config) return Promise.reject(err)</span><br><span class=\"line\">\t\tconfig._retryCount = config._retryCount || 0</span><br><span class=\"line\">\t\t//设置重连3次</span><br><span class=\"line\">\t\tif(config._retryCount&gt;3)return Promise.reject(err)</span><br><span class=\"line\">\t\tconfig.retryCount++</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t//2s延迟发起新请求</span><br><span class=\"line\">\t\tlet newReq= new Promise((rs)=&gt;&#123;</span><br><span class=\"line\">\t\t\tsetTimeout(()=&gt;&#123;</span><br><span class=\"line\">\t\t\t\trs()</span><br><span class=\"line\">\t\t\t&#125;,2000)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t\t//返回新的axios请求</span><br><span class=\"line\">\t\treturn newReq.then(function()&#123;</span><br><span class=\"line\">\t\t\treturn request(config)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><strong>说活对js&#x2F;node的事件循环机制</strong></p>\n<p>这个问题出现频率还是挺高的，主要考察面试者对js这门语言认识的深度，理解它的执行机制。在github上已经有人回答得很具体了：</p>\n<p><a class=\"link\"   href=\"https://github.com/febobo/web-interview/issues/167\" >说说对Nodejs中事件循环机制的理解<i class=\"fas fa-external-link-alt\"></i></a></p>\n<p><a class=\"link\"   href=\"https://github.com/febobo/web-interview/issues/73\" >说说你对事件循环的理解<i class=\"fas fa-external-link-alt\"></i></a></p>\n<p><strong>new 具体做了什么，如何实现一个new？</strong></p>\n<p><a class=\"link\"   href=\"https://github.com/febobo/web-interview/issues/69\" >这是答案<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h3 id=\"typescript\"><a href=\"#typescript\" class=\"headerlink\" title=\"typescript\"></a>typescript</h3><p><strong>ts中函数重载的概念？应用场景？</strong></p>\n<p>ts函数重载就是同一个函数提供多个函数类型，它的意义在于让你清晰的知道，传入不同的参数得到不同的结果，这也是它的应用场景。</p>\n<h3 id=\"vue全家桶\"><a href=\"#vue全家桶\" class=\"headerlink\" title=\"vue全家桶\"></a>vue全家桶</h3><p><strong>vuex的原理，如何按需加载</strong></p>\n<p>vuex是vuejs专用状态管理工具，采用集中式存储管理所有组件的状态，并保证状态以一种可预测的方式改变。</p>\n<p>它由以下几个部分组成：</p>\n<p><strong>state</strong></p>\n<p>单一存储状态，存储基本数据</p>\n<p><strong>getters</strong></p>\n<p>是计算属性，类似vue实例中的computed</p>\n<p><strong>mutations</strong></p>\n<p>state的更改在这里处理</p>\n<p><strong>actions</strong></p>\n<p>提交mutation去更改数据，往往包含异步操作。</p>\n<p><strong>module</strong></p>\n<p>分割模块，每个模块拥有独立的state、getters、mutantions、actions</p>\n<p>除此之外，vuex还提供了mapState,mapGetters.mapMutation,mapActions等函数，使得开发者在vm中更加方便地处理store.</p>\n<p>vuex和vue实例绑定是借助mixin，在初始化阶段之前把store注册到vue组件实例，并注册引用$store。借助vue的data实现state的响应，借助computed实现getters的实时监听。</p>\n<p>vuex按需加载，有时候我们进入首页，并不需要所有的vuex里面维护的状态，只需要加载首页用到的状态即可，这个时候就可以利用vuex提供的registerModule来按需异步加载不同的vuex模块。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if(isNeedVuexModule)&#123;</span><br><span class=\"line\">\timport(&#x27;./store/modules/&#x27;+moduleName).then(res=&gt;&#123;</span><br><span class=\"line\">\t\tthis.$store.registerModule(moduleName,res.default)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>vue中是如何监听数组的改变的</strong></p>\n<p>vue2在原因层面不支持用Object.defineProperty监听不存在的数组元素，并且通过一些能造成数组改变的方法也不能被监听到。vue2中重写了push，pop，shift，unshift，aplice.sort,reverse这七个数组方法，数组在执行这几个方法是手动触发响应页面的效果。至于为什么不去监听数组中已存在元素的变化，可参考：<a class=\"link\"   href=\"https://github.com/vuejs/vue/issues/8562\" >https://github.com/vuejs/vue/issues/8562<i class=\"fas fa-external-link-alt\"></i></a></p>\n<p><strong>谈谈vue.extend的作用</strong></p>\n<p>Vue提供的一个构造器，用于创建一个子类，参数是一个包含组件选型的对象，</p>\n<p>注意：Vue.extend创建的是一个构造器，而不是一个组件实例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//html</span><br><span class=\"line\">&lt;div id=&#x27;id&#x27;&gt;&lt;/div&gt;</span><br><span class=\"line\">//js</span><br><span class=\"line\">//创建构造器</span><br><span class=\"line\">var Child = Vue.extend(&#123;</span><br><span class=\"line\">\ttemplate:&#x27;&lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt;&#x27;,</span><br><span class=\"line\">\tdata()&#123;</span><br><span class=\"line\">\t\treturn&#123;</span><br><span class=\"line\">\t\t\tname:&#x27;Brian&#x27;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">new Child().$mount(&#x27;#id&#x27;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"前端架构\"><a href=\"#前端架构\" class=\"headerlink\" title=\"前端架构\"></a>前端架构</h3><p><strong>讲讲前端性能优化</strong></p>\n<p>1、减少http请求</p>\n<p>2、使用http2</p>\n<p>3、使用服务端渲染</p>\n<p>4、静态资源使用cdn</p>\n<p>5、css放在文件头部，JavaScript放在文件底部，还有async和deffer的使用</p>\n<p>6、使用字体图标代替图片图标</p>\n<p>7、善用缓存，不重复加载相同的内容，cache-control, service worker</p>\n<p>8、压缩文件</p>\n<p>9、图片优化</p>\n<ul>\n<li>-图片延迟加载</li>\n<li>-响应式图片，使用picture media</li>\n<li>-调整图片大小</li>\n<li>-降低图片质量</li>\n<li>-尽可能利用css3效果代替图片</li>\n<li>-使用webp格式的图片</li>\n</ul>\n<p>10、代码按需加载</p>\n<p>11、减少页面重排重绘</p>\n<ul>\n<li>-修改样式时不直接写样式，而是通过替换class来改变样式</li>\n<li>-先将dom元素脱离文档流，修改完之后再带回文档</li>\n</ul>\n<p>12、避免页面卡顿</p>\n<p>目前大多数设备的屏幕刷新率为 60 次&#x2F;秒。因此，如果在页面中有一个动画或渐变效果，或者用户正在滚动页面，那么浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致。 其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒&#x2F; 60 &#x3D; 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。</p>\n<p>13、使用requestAnimationFrame来实现视觉变化。</p>\n<p>由于大部分设备刷新频率为60次&#x2F;秒，每一帧的平均时间大概为16毫秒，js实现动画最好的情况就是在帧的开头开始执行，requestAnimationFrame正好可以满足这点</p>\n<p>14、使用webworker线程处理耗时操作</p>\n<p><strong>说说微前端架构</strong></p>\n<p>微前端其实是借鉴了微服务的概念，微服务大家都知道:后端(根据业务层次)分拆代码并形成独立的库，每个代码库负责自己的业务逻辑，并公开api，独立部署，分由不同团队维护。微前端借鉴了这种做法，把前端项目按照业务分拆成更小的单元，这些单元分由不同人员或团队开发维护，单独部署，其核心思想是远程应用程序和运行时加载。</p>\n<p>参考 <a class=\"link\"   href=\"https://zhuanlan.zhihu.com/p/414468874\" >深入解析微前端乾坤原理<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h3 id=\"打包-x2F-构建工具\"><a href=\"#打包-x2F-构建工具\" class=\"headerlink\" title=\"打包&#x2F;构建工具\"></a>打包&#x2F;构建工具</h3><p><strong>关于webpack，如何编写一个loader和plugin</strong></p>\n<p>1、关于loader</p>\n<p>由于webpack只能处理js文件，对于其他类型的文件需要专门的转换器处理一下再传入webpack，这个转换器就是loader。它对模块的源代码进行转换，将文件从不同的语言转换为JavaScript，也可将图像转换为data URL。loader其实就是一个函数，接受源模块，把处理结果传给下一个loader或webpack。</p>\n<p>下面来看看如何编写一个loader：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//一个把alert转为console.log的简单的loader</span><br><span class=\"line\">/loaders/alertToConsole.js</span><br><span class=\"line\">mudule.exports = function(source)&#123;</span><br><span class=\"line\">\t//source是webpack传入的源代码</span><br><span class=\"line\">\treturn source.replace(&#x27;alert&#x27;,&#x27;console.log&#x27;)//把alert转为console.log</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在webpack中配置该loader</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mudule:&#123;</span><br><span class=\"line\">\trules:[</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttest:/\\.js/,</span><br><span class=\"line\">\t\t\tuse:[</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tloader:path.resolve(_dirname,&#x27;./loaders/alertToConsole.js&#x27;)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，项目中所有js文件中的alert就都会被转成console.log了。当然，如果要实现一些复杂的功能可能要先把源代码转为ast，也就是抽象语法树，可以将其看成树形js对象，通过遍历ast树可以做一些复杂的操作，最后再转化成目标代码返回。</p>\n<p>2、关于plugin</p>\n<p>webpack的生命周期中会广播出很多事件，plugin可以监听这些事件，在合适的时间通过webpack的api去改变输出结果。</p>\n<p>一个简单的plugin的结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class myPlugin&#123;</span><br><span class=\"line\">\tconstructor(options)&#123;</span><br><span class=\"line\">\t\tconsole.log(&#x27;my plugin options&#x27;,options)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tapply(compiler)&#123;</span><br><span class=\"line\">\t\tcompiler.plugin(&#x27;done&#x27;,compilation=&gt;&#123;</span><br><span class=\"line\">\t\t\tdo something</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = myPlugin;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子中，可以把plugin看成带有apply方法的类。compiler代表webpack的整个生命周期，compilation代表依次新的编译过程。两者都暴露了钩子，可根据这些钩子编写一个满足实际需求的插件。</p>\n<p>下面实现一个简单的需求：生成打包文件之后输出一个包含“文件打包完毕”的.txt文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/plugins/txtPlugin.js</span><br><span class=\"line\">class txtPlugin&#123;</span><br><span class=\"line\">\tconstructor(options)&#123;</span><br><span class=\"line\">\t\tthis.options = options</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tapply(compiler)&#123;</span><br><span class=\"line\">\t\tcompiler.plugin(&#x27;done&#x27;,(compilation,callback)=&gt;&#123;</span><br><span class=\"line\">\t\t\tlet words &#x27;文件打包完毕&#x27;</span><br><span class=\"line\">\t\t\tcompilation.assets[&#x27;xxx.txt&#x27;]=&#123;</span><br><span class=\"line\">\t\t\t\tsource:function()&#123;</span><br><span class=\"line\">\t\t\t\t\treturn words</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\tsize:function()&#123;</span><br><span class=\"line\">\t\t\t\t\treturn words.length</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcallback()</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = txtPlugin</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const txtPlugin = require(&#x27;/plugins/txtPlugin.js&#x27;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">\tplugins:[</span><br><span class=\"line\">\t\tnew txtPlugin()</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、loader和plugin的区别</p>\n<p>loader遵循单一原则，只能做一件事，比如sass-loader,只能解析sass&#x2F;scss文件,而plugin是针对整个流程的，在这个流程中可以广泛地执行任务。</p>\n<h3 id=\"http-x2F-https\"><a href=\"#http-x2F-https\" class=\"headerlink\" title=\"http&#x2F;https\"></a>http&#x2F;https</h3><p><strong>http状态码</strong></p>\n<p>常见的http状态码：</p>\n<ul>\n<li>1表示消息 100临时相应，需要客户端继续发送请求 101 服务器根据客户端请求切换协议 主要用于websoket或http2升级</li>\n<li>2表示成功 200表示成功 201表示创建了新的资源 202 表示服务器已经接受了请求 但未处理 204服务器成功处理但不返回任何内容 206 表示处理了部分请求</li>\n<li>表示重定向 301&#x2F;308永久重定向 302&#x2F;307临时 304表示使用缓存</li>\n<li>4表示请求错误 400错误语法 401未授权 403服务器拒绝 404未找到 407需要代理 408超时</li>\n<li>5表示服务器错误 500服务器内部错误 502网关错误 504网关超时 505 http版本的问题</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p><strong>路由&#x2F;按钮权限控制是怎么做的</strong></p>\n<p>参考 <a class=\"link\"   href=\"https://juejin.cn/post/6844903933429678094\" >https://juejin.cn/post/6844903933429678094<i class=\"fas fa-external-link-alt\"></i></a></p>\n<p><strong>webapp如何做缓存</strong></p>\n<p>serviceWorker,ApplicationCache ,LocalStorage,indexedDb</p>\n","categories":["技术"],"tags":["web前端","面试"]},{"title":"分享一款特别适合切图的截图工具","url":"/2020/12/20/%E5%88%86%E4%BA%AB%E4%B8%80%E6%AC%BE%E7%89%B9%E5%88%AB%E9%80%82%E5%90%88%E5%88%87%E5%9B%BE%E7%9A%84%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7/","content":"<p>推荐一款特别适合前端切图的截图工具。它的主要功能是截图、贴图和取色，由国人开发，完全免费，无广告，体积小却功能逆天，个人觉得是目前用过的最好用的截图工具。</p>\n<p>下载地址：</p>\n<p><a class=\"link\"   href=\"https://www.snipaste.com/\" >https://www.snipaste.com/<i class=\"fas fa-external-link-alt\"></i></a></p>\n<p>或者</p>\n<p>链接：<a class=\"link\"   href=\"https://pan.baidu.com/s/1klNDMibTT4rsKJ2ceu_coQ\" >https://pan.baidu.com/s/1klNDMibTT4rsKJ2ceu_coQ<i class=\"fas fa-external-link-alt\"></i></a><br>提取码：pyvz</p>\n","categories":["工具"],"tags":["截图工具"]},{"title":"electron从入门到入门","url":"/2020/04/04/electron%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/","content":"<h5 id=\"electron是什么\"><a href=\"#electron是什么\" class=\"headerlink\" title=\"electron是什么\"></a>electron是什么</h5><p>electron就是使用web技术创建跨平台原生桌面应用的框架。electron用web页面作为它的GUI，结合chromium、nodejs和用于调用操作系统本地功能的APIs. 可以把electron看成包含chromium和node的运行时环境，可以简单得理解成web运行在node上。</p>\n<h5 id=\"主进程、渲染进程\"><a href=\"#主进程、渲染进程\" class=\"headerlink\" title=\"主进程、渲染进程\"></a>主进程、渲染进程</h5><p>这是electron中比较重要的两个概念。主进程是运行package.json里main脚本的进程成为主进程，用来展示页面的进程成为渲染进程。这两个进程通过ipc模块进行通信。</p>\n<h5 id=\"第一个electron应用\"><a href=\"#第一个electron应用\" class=\"headerlink\" title=\"第一个electron应用\"></a>第一个electron应用</h5><p>1、初始化一个npm项目，安装electron</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm init -y &amp;&amp; npm i electron -D</span><br></pre></td></tr></table></figure>\n\n<p>2、创建index.js(主进程执行代码)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123;app,BrouserWindow&#125; = require(&#x27;electron&#x27;)</span><br><span class=\"line\">//创建全局变量，避免被gc</span><br><span class=\"line\">let win</span><br><span class=\"line\">function createWin()&#123;</span><br><span class=\"line\">\t//创建窗口，设置宽高</span><br><span class=\"line\">\twin = new BrowserWindow(&#123;width:1000,height:800&#125;)</span><br><span class=\"line\">\t//加载页面</span><br><span class=\"line\">\twin.loadFile(&#x27;./index.html&#x27;)</span><br><span class=\"line\">\twin.webContents.openDevTools()//打开开发者工具</span><br><span class=\"line\">\t//监听窗口关闭时间</span><br><span class=\"line\">\twin.on(&#x27;closed&#x27;,()=&gt;&#123;</span><br><span class=\"line\">\t\twin = null//取消引用</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//初始化</span><br><span class=\"line\">app.on(&#x27;ready&#x27;,createWindow)</span><br><span class=\"line\">//当关闭全部窗口时</span><br><span class=\"line\">app.on(&#x27;window-all-closed&#x27;,()=&gt;&#123;</span><br><span class=\"line\">\tif(process.platform !==&#x27;darwin&#x27;)&#123;</span><br><span class=\"line\">\t\tapp.quit()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.on(&#x27;activate&#x27;,()=&gt;&#123;</span><br><span class=\"line\">\tif(win === null)&#123;</span><br><span class=\"line\">\t\tcreateWindow()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>接下来创建一个简单的html页面</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//index.html</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">\t&lt;head&gt;</span><br><span class=\"line\">\t\t&lt;meta charset=&#x27;utf-8&#x27;&gt;</span><br><span class=\"line\">\t\t&lt;title&gt;first app&lt;/title&gt;</span><br><span class=\"line\">\t&lt;/head&gt;</span><br><span class=\"line\">\t&lt;body&gt;</span><br><span class=\"line\">\t\t&lt;div&gt;hello world&lt;/div&gt;</span><br><span class=\"line\">\t&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在package.json中scripts添加 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tmain:&#x27;index.js&#x27;，</span><br><span class=\"line\">\tscripts:&#123;</span><br><span class=\"line\">\t\t&#x27;dev&#x27;:&#x27;electron .&#x27;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>打开终端输入npm run dev,将会弹出刚刚的应用。</p>\n<h5 id=\"主进程和渲染进程的通信\"><a href=\"#主进程和渲染进程的通信\" class=\"headerlink\" title=\"主进程和渲染进程的通信\"></a><strong>主进程和渲染进程的通信</strong></h5><p><em>ipcMain和ipcRenderer</em></p>\n<p>ipcMain在主进程中使用，用来处理渲染进程发送的信息</p>\n<p>ipcRenderer在渲染进程中使用，用来发送消息给主进程，也可用来接收主进程的回复信息。</p>\n<p>主进程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123;ipcMain&#125; = require(&#x27;electron&#x27;)</span><br><span class=\"line\">//监听渲染进程发来的消息</span><br><span class=\"line\">ipcMain.on(&#x27;ping&#x27;,(e,data)=&gt;&#123;</span><br><span class=\"line\">\te.sender.send(&#x27;pong&#x27;,&#x27;main返回的值&#x27;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>渲染进程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123;ipcRenderer&#125; = require(&#x27;electron&#x27;)</span><br><span class=\"line\">//发送消息给主进程</span><br><span class=\"line\">ipcRenderer.send(&#x27;ping&#x27;,&#x27;传给main&#x27;)</span><br><span class=\"line\">//监听主进程发来的消息</span><br><span class=\"line\">ipcRenderer.on(&#x27;pong&#x27;,(e,data)=&gt;&#123;</span><br><span class=\"line\">\tconsole.log(data)//我是主进程返回的值</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><em>remote模块</em></p>\n<p>使用remote模块可以直接调用主进程对象的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123;dialog&#125; = require(&#x27;electron&#x27;).remote</span><br><span class=\"line\">dialog.showMessageBox(&#x27;你好，世界&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p><em>webContents</em></p>\n<p>webContents负责渲染和控制页面，是BrowserWindow的一个属性。我们可以使用它的send方法像渲染进程发送消息</p>\n<p>主进程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123;app,BrowserWindow&#125; = require(&#x27;electron&#x27;)</span><br><span class=\"line\">let win </span><br><span class=\"line\">app.on(&#x27;ready&#x27;,()=&#123;</span><br><span class=\"line\">\twin = new BrowserWindow(&#123;width:1000,height:800&#125;)</span><br><span class=\"line\">\twin.loadFile(&#x27;./index.html&#x27;)</span><br><span class=\"line\">\t//导航完成时触发</span><br><span class=\"line\">\twin.webContents.on(&#x27;dif-finish-load&#x27;,()=&gt;&#123;</span><br><span class=\"line\">\t\twin.webContents.send(&#x27;ping&#x27;,&#x27;send to renderer process&#x27;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>渲染进程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123;ipcRenderer&#125; = require(&#x27;electron&#x27;)</span><br><span class=\"line\">ipcRenderer.on(&#x27;ping&#x27;,(e,data)=&gt;&#123;</span><br><span class=\"line\">\tconsole.log(data)// send to renderer process</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>至此，你已经知道如何创建页面以及进程间通信，可以编写简单的electron应用了~~</p>\n","categories":["技术","electron"],"tags":["electron","桌面应用","跨平台"]},{"title":"python3快速入门","url":"/2022/04/05/python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","content":"<h5 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h5><p>有一定的编程基础，入门一门高级编程语言其实不难，但是要达到”出神入化”的使用效果，还是得下一番功夫并且经过大量的代码锤炼。话不多说，本文主要通过精炼简洁的描述呈现如何入门python3这门语言，至于一些更深层次或边界问题，会在后续关于python3的文章中有所涉及。</p>\n<h5 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h5><p>python是一种结合了解释性、编译性、互动性和面向对象的脚本语言。它的特点是可移植、可拓展、可嵌入，强面向对象。</p>\n<h5 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h5><p>#单行注释</p>\n<p>‘’’或者“”“多行注释</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#单行注释</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">多行注释</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">这也是多行注释</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"行和缩进\"><a href=\"#行和缩进\" class=\"headerlink\" title=\"行和缩进\"></a>行和缩进</h5><p>python的特点就是利用缩进表示代码块。同一个代码块的语句必须包含相同的缩进空格数，否则报错。</p>\n<h5 id=\"多行语句\"><a href=\"#多行语句\" class=\"headerlink\" title=\"多行语句\"></a>多行语句</h5><p>python通过反斜杠来实现多行语句</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">str</span> = str1 +\\</span><br><span class=\"line\">\t  str2 +\\</span><br><span class=\"line\">      str3</span><br></pre></td></tr></table></figure>\n\n<p>如果在[],{},（）中，多行语句不需要使用反斜杠</p>\n<h5 id=\"空行\"><a href=\"#空行\" class=\"headerlink\" title=\"空行\"></a>空行</h5><p>空行一般用于分割不同功能或涵义的代码，使其更加方便维护和重构。</p>\n<h5 id=\"用户输入\"><a href=\"#用户输入\" class=\"headerlink\" title=\"用户输入\"></a>用户输入</h5><p>input函数可以接受用户输入</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">str</span> = <span class=\"built_in\">input</span>(<span class=\"string\">&#x27;请输入 然后按回车键&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">str</span>)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"模块导入\"><a href=\"#模块导入\" class=\"headerlink\" title=\"模块导入\"></a>模块导入</h5><p>将整个模块导入，格式为：<code>import module_name</code></p>\n<p>从某个模块中导入某个函数,格式为：<code>from module_name import func1</code></p>\n<p>从某个模块中导入多个函数,格式为：<code>from module_name import func1, func2, func3</code></p>\n<p>将某个模块中的全部函数导入，格式为：<code>from module_name import *</code></p>\n<h5 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h5><p>变量必须在使用前声明好，不然会报错</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">name = <span class=\"string\">&#x27;Brian&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(name)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h5><p>1、布尔类型</p>\n<p>只有True和False,用来表示真和假</p>\n<p>2、数字类型</p>\n<p>包括整型、浮点型、复数</p>\n<ul>\n<li>不同类型的数字混合运算时会将整数转换为浮点数</li>\n<li>在不同的机器上浮点运算的结果可能会不一样</li>\n<li>在整数除法中，除法 <code>/</code> 总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 <code>//</code>。</li>\n<li><code>//</code> 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系</li>\n<li>在交互模式中，最后被输出的表达式结果被赋值给变量 <code>_</code>，<code>_</code> 是个只读变量</li>\n</ul>\n<p>常见的数学函数</p>\n<p>abs、fabs、ceil、floor、<br>（未完待续）</p>\n","categories":["技术","python"],"tags":["python","入门"]},{"title":"写点什么","url":"/2020/01/05/%E5%86%99%E7%82%B9%E4%BB%80%E4%B9%88/","content":"<p>工作以来，我是”踩在巨人的肩膀”上成长的。</p>\n<p>不管是专家们的书籍还是行业大佬的博客，每每阅读，总能让自己受益匪浅。</p>\n<p>作为互联网开源思想的受益者，也总想着是否可以做出一点贡献，闲暇时写一些技术类的文章，为后来者指点迷津。</p>\n<p>但是，总感觉自己技术还不够硬，不敢误人子弟，也就迟迟没有行动。</p>\n<p>继续作为一个“伸手党”，把”拿来主义“奉行到底。</p>\n<p>时间一长，总感觉羞愧丢人。</p>\n<p>遂，下定决心，在不断加强相关技术认知的同时，抽空写一写技术博客，分享自己的学习历程。</p>\n<p>如果可能，给予阅读者一丁点”答疑解惑”</p>\n<p>或可聊以慰藉。</p>\n","categories":["随感"],"tags":["起点"]},{"title":"css奇技淫巧之currentColor","url":"/2021/08/05/css%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%E4%B9%8BcurrentColor/","content":"<h5 id=\"currentColor\"><a href=\"#currentColor\" class=\"headerlink\" title=\"currentColor\"></a>currentColor</h5><p>相信不少前端同学没听过这个，也许会疑惑，css里面有这东西？哈哈，有的，它用来表示当前文字的颜色，不管当前文字的颜色是直接设置还是继承的。下面代码说明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\tcolor:yellow;</span><br><span class=\"line\">\tbackground:currentColor; //这里currentColor就是yellow</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//同样的</span><br><span class=\"line\">.box&#123;</span><br><span class=\"line\">\tcolor:yellow;</span><br><span class=\"line\">\t.inner-box&#123;</span><br><span class=\"line\">\t\tbackground:currentColor;//文字颜色继承而来，所以这里的currentColor也是yellow</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有，border和box-shadow的默认值都是currentColor，也就是说，这两个属性不设置颜色值时默认采用currentColor,比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\tcolor:yellow;</span><br><span class=\"line\">\tborder:1px solid;//等同于  border:1px solid yellow;</span><br><span class=\"line\">\tbox-shadow:0 0 0;//等同于 box-shadow:0 0 0 yellow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["技术","web前端","css"],"tags":["css"]},{"title":"css奇技淫巧之all","url":"/2021/12/05/css%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%E4%B9%8Ball/","content":"<h5 id=\"all属性\"><a href=\"#all属性\" class=\"headerlink\" title=\"all属性\"></a>all属性</h5><p>all属性将除unicode-bidi和direction之外的所有属性重置为其初始值或继承的值。属性值有initial、inherit和unset。</p>\n<p>下面用代码说明<br> <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> //html</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;div class=&#x27;container&#x27;&gt;123&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//css</span><br><span class=\"line\">body&#123;</span><br><span class=\"line\">\tcolor:blue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.container&#123;</span><br><span class=\"line\">\tcolor:red;</span><br><span class=\"line\">\tall:inherit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> 得到的结果将会是</p>\n<p> <img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://s1.328888.xyz/2022/04/09/XOmiF.png\"\n                      alt=\"XOmiF.png\"\n                ></p>\n<p> 如果把all设置为initial，将会得到一个初始值</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://s1.328888.xyz/2022/04/09/XO3Zy.png\"\n                      alt=\"XO3Zy.png\"\n                ></p>\n<p>如果all:unset,则表示，如果可继承，则将应用于元素或元素父元素的所有属性更改为其父值，否则将其更改为初始值。</p>\n","categories":["技术","web前端","css"],"tags":["css"]},{"title":"css奇技淫巧之background-clip","url":"/2021/09/05/css%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%E4%B9%8Bbackground-clip/","content":"<p>这是一个有趣的属性，它让我们可以为元素的背景设置自定义图形。</p>\n<p>我们的自定义图形可以延伸到元素的边框，内边距盒或内容盒。</p>\n<p>看看代码实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p class=&quot;border-box&quot;&gt;背景延伸到边框。&lt;/p&gt;</span><br><span class=\"line\">&lt;p class=&quot;padding-box&quot;&gt;背景延伸到边框的内部边缘。&lt;/p&gt;</span><br><span class=\"line\">&lt;p class=&quot;content-box&quot;&gt;背景仅延伸到内容盒的边缘。&lt;/p&gt;</span><br><span class=\"line\">&lt;p class=&quot;text&quot;&gt;背景被裁剪为前景文本。&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<p>css部分：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">p &#123;</span><br><span class=\"line\">    border: .8em darkviolet;</span><br><span class=\"line\">    border-style: dotted double;</span><br><span class=\"line\">    margin: 1em 0;</span><br><span class=\"line\">    padding: 1.4em;</span><br><span class=\"line\">    background: linear-gradient(60deg, red, yellow, red, yellow, red);</span><br><span class=\"line\">    font: 900 1.2em sans-serif;</span><br><span class=\"line\">    text-decoration: underline;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.border-box &#123;</span><br><span class=\"line\">    background-clip: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.padding-box &#123;</span><br><span class=\"line\">    background-clip: padding-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.content-box &#123;</span><br><span class=\"line\">    background-clip: content-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.text &#123;</span><br><span class=\"line\">    background-clip: text;</span><br><span class=\"line\">    -webkit-background-clip: text;</span><br><span class=\"line\">    color: rgba(0, 0, 0, .2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终得到的效果</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://s1.328888.xyz/2022/04/09/Xnhtk.png\"\n                      alt=\"Xnhtk.png\"\n                ></p>\n","categories":["技术","web前端","css"],"tags":["css"]},{"title":"css奇技淫巧之writing-mode","url":"/2021/03/05/css%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%E4%B9%8Bwriting-mode/","content":"<p>writing-mode用来定义文本在水平或者垂直方向上如何排布，控制文本的展示方向。</p>\n<p>属性值：</p>\n<ul>\n<li><p>horizontal-tb：水平方向自上而下的书写方式。即 left-right-top-bottom</p>\n</li>\n<li><p>vertical-rl：垂直方向自右而左的书写方式。即 top-bottom-right-left</p>\n</li>\n<li><p>vertical-lr：垂直方向内内容从上到下，水平方向从左到右</p>\n</li>\n<li><p>sideways-rl：内容垂直方向从上到下排列</p>\n</li>\n<li><p>sideways-lr：内容垂直方向从下到上排列</p>\n</li>\n</ul>\n<p>MDN Web的具体描述：</p>\n<p> <img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://s1.328888.xyz/2022/04/09/XnXN0.png\"\n                      alt=\"XnXN0.png\"\n                ></p>\n","categories":["技术","web前端","css"],"tags":["css"]},{"title":"javascript之原型","url":"/2021/06/10/javascript%E4%B9%8B%E5%8E%9F%E5%9E%8B/","content":"<p>es5中没有类的概念，他的继承是基于原型的，每个函数都有一个prototype属性，指向函数的原型对象。每一个对象有关联一个原型对象，用__proto__属性可以访问到这个原型对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Person(name,gender)&#123;</span><br><span class=\"line\">    this.name =name</span><br><span class=\"line\">    this.gender = gender</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const Brian = new Person(&#x27;Brian&#x27;,&#x27;male&#x27;)</span><br><span class=\"line\">Person.prototype.getName = function()&#123;</span><br><span class=\"line\">    return this.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.country = &quot;cn&quot;</span><br><span class=\"line\">console.log(Brian.__proto__==Person.prototype) //true</span><br><span class=\"line\">console.log(Brian.getName()) //Brian</span><br><span class=\"line\">console.log(Brian.country) // cn</span><br></pre></td></tr></table></figure>\n<p>从上面的例子中可以看出，实例的__proto__和 构造函数的prototype属性指向的是同一个对象，也就是原型，实例会继承原型上的属性和方法，country和getName就是继承自原型。</p>\n<p>构造函数、原型和实例之间的关系就是：每个函数都有一个原型对象(prototype)，原型对象都包含这一个指向构造函数的指针(constructor),而实例都包含一个指向原型对象的内部指针(proto)。假如我们让原型对象等于另一个类型的实例，这时的原型对象将包含一个指向另一个原型的指针，同样另一个原型中也包含着一个指向另一个构造函数的指针。如果另一个原型又是另一个类型的实例，这样上面描述的关系仍会成立，这样层层递进，构成了实例与原型的链条，就是原型链。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Cat()&#123;&#125;</span><br><span class=\"line\">Cat.prototype.constructor == Cat //true</span><br></pre></td></tr></table></figure>\n<p>原型中包含一个指向构造函数的指针，也就是说构造函数的原型的构造函数指向其自身，因此，可以把原型看成构造函数的一个特殊实例，其他实例”共享”这个特殊实例的属性和方法。看下面代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Animal()&#123;&#125;</span><br><span class=\"line\">let cat = new Animal() //普通实例</span><br><span class=\"line\">Animal.prototype.name = &#x27;cat&#x27; //把原型看成Animal的一个特殊实例</span><br><span class=\"line\">Animal.prototype.getName = function()&#123;</span><br><span class=\"line\">    return this.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(cat.name) //cat</span><br><span class=\"line\">console.log(cat.getName()) //cat</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，就算name和getName是在实例化得到cat后定义的，cat依旧可以访问到他们的，这也说明，实例“共享”原型的属性和方法。</p>\n<p>在js中，一切皆对象，由Function创建的是函数对象(包括Function本身)，由Object创建的是普通对象。既然都是对象，除了普通对象外，函数对象也会有一个指向其构造函数原型对象的指针，也就是所有函数的__proto__属性都指向Function.prototype,而Function.prototype是个普通对象，所以Function.prototype.__proto__指向Object.prototype,所有对象都有一个指针指向原型对象，但是由于Object.prototype已经到了最顶端，所以Object.prototype.<strong>proto</strong> 指向null。</p>\n<p>会发现，除Object本身外，其他内置函数的原型都是由Object创建，这其中除了Function.prototype是函数对象外，其余的都是普通对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object.prototype instanceof Object //false</span><br><span class=\"line\">typeof Object.prototype == &#x27;object&#x27; // true</span><br><span class=\"line\">typeof Function.prototype == &#x27;function&#x27; // true</span><br><span class=\"line\">typeof Array.prototype == &#x27;object&#x27; //true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>为什么Object.prototype.constructor是Object，说明Object.prototype是由Object创建的，但是，为什么Object.prototype instanceof Object 的结果却是false呢？原因是instanceof是通过查找原型链判断，由于Object.prototype已经到达最顶端，它的__proto__属性指向null。<br>然后会有一些有趣的现象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Function.constructor == Function // true</span><br><span class=\"line\">Function.__proto__ == Function.prototype //true</span><br><span class=\"line\">Object instanceof Object // true </span><br><span class=\"line\">Function instanceof Function //true</span><br><span class=\"line\">Function instanceof Object //true</span><br><span class=\"line\">Object instanceof Function //true</span><br></pre></td></tr></table></figure>\n<p>可以看出Function和Object，我中有你，你中有我，却最终又指向一个null。这是js这门语言的奇妙之处。</p>\n<p><a class=\"link\"   href=\"https://www.jianshu.com/p/08c07a953fa0\" >参考:https://www.jianshu.com/p/08c07a953fa0<i class=\"fas fa-external-link-alt\"></i></a></p>\n","categories":["技术","web前端","javascript"],"tags":["javascript","js"]},{"title":"javascript之闭包","url":"/2021/04/09/javascript%E4%B9%8B%E9%97%AD%E5%8C%85/","content":"<p>javascript中闭包是一个很重要的概念，它有三个特点：</p>\n<ul>\n<li>函数嵌套函数</li>\n<li>函数内部可以引用外部的参数和变量</li>\n<li>参数和变量不会被垃圾回收机制回收</li>\n</ul>\n<p>闭包一般用来设计私有的方法和变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function aaa() &#123;  \t</span><br><span class=\"line\">    var a = 1;  \t\t</span><br><span class=\"line\">    return function()&#123;\t\t</span><br><span class=\"line\">        alert(a++)\t</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var fun = aaa();</span><br><span class=\"line\">fun();// 1 执行后 a++，，然后a还在</span><br><span class=\"line\">fun();// 2   </span><br><span class=\"line\">fun = null;//a被回收！！</span><br></pre></td></tr></table></figure>\n<p>闭包的好处是，使得一个变量长期驻留在内存，避免全局变量的污染。但是，正是由于常驻内存，会增大内存使用量，处理不当就会造成内存泄漏。</p>\n<p>看下面这段代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function add () &#123;  </span><br><span class=\"line\">    var test = 0;  </span><br><span class=\"line\">    return function () &#123;    </span><br><span class=\"line\">        test++;    </span><br><span class=\"line\">        return test;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var test = add();</span><br><span class=\"line\">console.log(test()); // 1</span><br><span class=\"line\">console.log(test()); // 2</span><br><span class=\"line\">console.log(test()); // 3</span><br><span class=\"line\">console.log(test()); // 4</span><br><span class=\"line\">console.log(test()); // 5</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>闭包保持对test的引用，除非手动清除，否则它会常驻内存。</p>\n","categories":["技术","web前端"],"tags":["javascript"]},{"title":"前端知识问答(二)","url":"/2022/04/12/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93(%E4%BA%8C)/","content":"<h3 id=\"同源策略和跨域请求\"><a href=\"#同源策略和跨域请求\" class=\"headerlink\" title=\"同源策略和跨域请求\"></a>同源策略和跨域请求</h3><p>同源策略是一种阻止不同域之间的内容进行交互，隔离潜在恶意文件的关键完全机制，当一个请求URL的协议，域名、端口三者之间只要有一个不同就是跨域了。同源策略的目的只为了保证用户信息安全，防止恶意的网站窃取用户数据。如果网页之间不满足”同源”的要求，他们将不能共享cookie、localStorage、IndexDB，不能获取DOM，Ajax请求不能发送。<br>关于请求，同源策略并不是浏览器不让请求发送出去、或者后端拒绝返回数据，而是请求正常发出去了，后端也响应了，只是数据到了浏览器被浏览器组织并且丢弃了。但是也有例外，想img src,link href,script src这些是允许跨域加载的。<br>由此产生的问题就是跨域问题。怎么解决呢？<br>目前主流的做法是JSONP和CORS。<br>先讲讲jsonp，上面提到script允许跨域加载，jsonp就是通过这个实现数据接口跨域请求的。<br>当发生请求时，在客户端动态添加一个script标签，他的地址指向第三方地址，让后约定好处理结果的函数也可以通过url参数传递给后端，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://api.djsdf.com/v1/userinfo?userId=123&amp;cb=getUserInfoById</span><br></pre></td></tr></table></figure>\n<p>根据上面所说的是通过script,那么在客户端页面上将会增加</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://api.djsdf.com/v1/userinfo?userId=123&amp;cb=getUserInfoById&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>服务端处理这个请求，然后返回</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">getUserInfoById(&#123;&quot;name&quot;:&quot;hdfsd&quot;,&quot;gender&quot;:&quot;male&quot;&#125;)</span><br></pre></td></tr></table></figure>\n<p>在客户端定义好getUserInfoById这个处理函数，当服务器返回上面的内容时，这个函数将会被调用，传入的参数就是要获取的内容。<br>jsonp的优点是兼容性好，缺点也很明显，只支持get请求。</p>\n<p>接下来说说CORS<br>中文名叫跨站资源共享机制，这个是真正的跨域访问。它需要浏览器和服务器同时支持。除ie9及以下浏览器外，其他浏览器都支持这个功能。</p>\n<p>CORS请求是浏览器自动完成的。对于开发者来说，和同源Ajax没什么区别，浏览器一旦发现ajax请求跨域，就会自动添加附加的头信息，因此实现CORS通信的关键是服务器，只要服务器CORS接口，即可跨域通信。</p>\n<p>如果服务器实现了跨域，就会返回给浏览器CORS头(Access-Control-Allow-Origin),这是浏览器就会正常处理返回的数据，而不是因为同源策略将其丢弃。</p>\n<p>需要注意的是，浏览器会将cors请求分为简单请求和非简单请求。<br>满足以下两大条件就是简单请求：<br>1、请求方法是head、get、post之一<br>2、请求只会包含Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type(值只为application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain)<br>除此之外，其余的都是非简单请求。<br>对于这两种请求，浏览器的处理会有所不同。<br>对于简单请求，浏览器是直接发出，在头信息中增加一个Origin字段，表示本次请求来自哪个源，服务器根据这个值决定是否同意这次请求。如果origin不在允许的范围，服务器会返回一个不包含以Access-Control为开头的信息头的http响应，这时浏览器会丢弃返回结果。如果origin在允许范围内，则服务器将会返回带有以下消息头的的响应：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class=\"line\">Access-Control-Allow-Credentials: true</span><br><span class=\"line\">Access-Control-Expose-Headers: AppInfo</span><br><span class=\"line\">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>\n\n<p>其中，第一个是必须的，它表示允许请求的域，也可以设置为*，表示允许所有域的请求。</p>\n<p>Access-Control-Allow-Credentials表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。它是可选的。</p>\n<p>Access-Control-Expose-Headers。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;AppInfo&#39;)</code>可以返回<code>AppInfo</code>字段的值。</p>\n<p>有一个需要特别注意的是，上面提到Access-Control-Allow-Credentials表示是允许发送cookie，只是把这个设置为true还不行，还应在前端显示设置withCredentials为true:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var xhr = new XMLHttpRequest();</span><br><span class=\"line\">xhr.withCredentials = true;</span><br></pre></td></tr></table></figure>\n\n<p>否则，浏览器不会发送cookie。</p>\n<p>还需要额外注意的是，如果要发送cookie，就不能把Access-Control-Allow-Origin设置为星号(*)，他应该与发出请求一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨域）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</p>\n<p>非简单请求，在第一次请求的时候会有一次预检验请求，用来检验当前请求源是否在允许范围内，如果预检验通过，以后每次请求就跟简单请求差不多，会自动在请求头里面加上origin，服务器返回信息中也会包含Access-Control-Allow-Origin这个消息头。预检验请求检验origin、请求方法method、还有自定义消息头是否在允许范围内，如果允许，就在响应头中增加cors头消息，接着浏览器发起真正的请求，否则，正常返回，浏览器报错，提示不允许跨域。</p>\n<p>需要额外注意的是，预检验请求如果通过还可返回一个头消息：Access-Control-Max-Age，用来告诉浏览器多久之内不用再发一次预检验请求。</p>\n<p>CORS部分参考<a class=\"link\"   href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" >http://www.ruanyifeng.com/blog/2016/04/cors.html<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h3 id=\"BFC的作用\"><a href=\"#BFC的作用\" class=\"headerlink\" title=\"BFC的作用\"></a>BFC的作用</h3><p>参考<a class=\"link\"   href=\"https://www.jianshu.com/p/1f91e136b22d\" >https://www.jianshu.com/p/1f91e136b22d<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h3 id=\"cookie、session和token的区别？使用？\"><a href=\"#cookie、session和token的区别？使用？\" class=\"headerlink\" title=\"cookie、session和token的区别？使用？\"></a>cookie、session和token的区别？使用？</h3><p>参考<a class=\"link\"   href=\"https://www.jianshu.com/p/3ec89874b196\" >https://www.jianshu.com/p/3ec89874b196<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h3 id=\"echart自适应？\"><a href=\"#echart自适应？\" class=\"headerlink\" title=\"echart自适应？\"></a>echart自适应？</h3><p>通过监听浏览器窗口的resize时间，然后调用echart图表实例的resize方法。</p>\n<h3 id=\"vue-nextTick的作用？\"><a href=\"#vue-nextTick的作用？\" class=\"headerlink\" title=\"vue nextTick的作用？\"></a>vue nextTick的作用？</h3><p>官方定义：</p>\n<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</p>\n<p>vue中试图的更新是异步的，也就是说，修改数据，vue不会理解更新视图，而是将这次”更新”放到一个异步队列中，等到所有数据都已经更改完，对这个异步队列进行去重，然后逐一更新视图，视图更新完毕后，如果更改数据后面紧跟着有nextTick，将会去执行nextTick里面传入的操作。</p>\n<p>参考<a class=\"link\"   href=\"https://www.jianshu.com/p/dce747bc708f\" >https://www.jianshu.com/p/dce747bc708f<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h3 id=\"js的垃圾回收机制？\"><a href=\"#js的垃圾回收机制？\" class=\"headerlink\" title=\"js的垃圾回收机制？\"></a>js的垃圾回收机制？</h3><p>参考<a class=\"link\"   href=\"https://www.cnblogs.com/94pm/p/16026887.html\" >https://www.cnblogs.com/94pm/p/16026887.html<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h3 id=\"vuex的优缺点？\"><a href=\"#vuex的优缺点？\" class=\"headerlink\" title=\"vuex的优缺点？\"></a>vuex的优缺点？</h3><p>优点</p>\n<p>1.集中管理共享的数据,易于开发和后期维护</p>\n<p>2.数据是响应是的，状态更改，会触发视图的更新</p>\n<p>3.以js原生对象形式存储对象，使用方便</p>\n<p>4.以一种可预测的方式改变数据，避免了数据污染</p>\n<p>缺点</p>\n<p>1.浏览器刷新会导致所有数据变为初始状态</p>\n<p>不过这个缺点可通过插件 vuex-persistedstate解决</p>\n<h3 id=\"keep-alive属性及生命周期\"><a href=\"#keep-alive属性及生命周期\" class=\"headerlink\" title=\"keep-alive属性及生命周期\"></a>keep-alive属性及生命周期</h3><p>KeepAlive是vue内置组件，用来缓存组件</p>\n<p>它的属性包括：</p>\n<ul>\n<li><p>include包含的组件(可以为字符串，数组，以及正则表达式,只有匹配的组件会被缓存)</p>\n</li>\n<li><p>exclude排除的组件(以为字符串，数组，以及正则表达式,任何匹配的组件都不会被缓存)</p>\n</li>\n<li><p>max缓存组件的最大值(类型为字符或者数字,可以控制缓存组件的个数)</p>\n</li>\n</ul>\n<p>它的生命周期有activated和deacitvated</p>\n<p>执行顺序是created-&gt;mounted-&gt;activated,退出是执行deactivated，再次进入执行activated</p>\n<h3 id=\"electron如何自定义安装-x2F-卸载界面\"><a href=\"#electron如何自定义安装-x2F-卸载界面\" class=\"headerlink\" title=\"electron如何自定义安装&#x2F;卸载界面\"></a>electron如何自定义安装&#x2F;卸载界面</h3><p>参考<a class=\"link\"   href=\"https://blog.51cto.com/u_15127581/4318016\" >https://blog.51cto.com/u_15127581&#x2F;4318016<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h3 id=\"vue实现双向绑定的原理\"><a href=\"#vue实现双向绑定的原理\" class=\"headerlink\" title=\"vue实现双向绑定的原理\"></a>vue实现双向绑定的原理</h3><p>参考：</p>\n<p><a class=\"link\"   href=\"https://www.jianshu.com/p/87bd5e6f6263\" >https://www.jianshu.com/p/87bd5e6f6263<i class=\"fas fa-external-link-alt\"></i></a></p>\n<p><a class=\"link\"   href=\"https://www.cnblogs.com/libin-1/p/6893712.html\" >https://www.cnblogs.com/libin-1/p/6893712.html<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h3 id=\"vue父子组件的生命周期顺序\"><a href=\"#vue父子组件的生命周期顺序\" class=\"headerlink\" title=\"vue父子组件的生命周期顺序\"></a>vue父子组件的生命周期顺序</h3><p>初次加载：</p>\n<p>父beforeCreated-&gt;created-&gt;beforeMount-&gt;子beforeCreated-&gt;created-&gt;beforeMount-&gt;mounted-&gt;父mounted</p>\n<p>此阶段就是父组件创建，子组件创建，子组件挂载，父组件挂载</p>\n<p>需要特别注意的是，如果组件是异步引入，执行顺序是</p>\n<p>父组件创建，父组件挂载，子组件创建，子组件挂载</p>\n<p>更新</p>\n<p>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p>\n<p>销毁</p>\n<p>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p>\n","categories":["技术"],"tags":["web前端","面试"]},{"title":"javascript之变量提升和函数提升","url":"/2022/02/16/javascript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/","content":"<h3 id=\"变量提升和函数提升是什么\"><a href=\"#变量提升和函数提升是什么\" class=\"headerlink\" title=\"变量提升和函数提升是什么\"></a>变量提升和函数提升是什么</h3><p>按照字面的意思，感觉像是变量被提到了代码的最前面，但其实不是，js作为一门解释性语言，它是一段一段执行的，在编译阶段一些变量被提前放入到内存中，导致了”变量提升”。初次之外还有函数提升，需要注意的是函数提升优先与变量提升。需要注意的是，变量提升只是声明提升，提升后值为undefined。</p>\n<p>变量提升的例子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log(a)//undefined</span><br><span class=\"line\">var a = &#x27;123&#x27;</span><br><span class=\"line\">console.log(a) //123</span><br></pre></td></tr></table></figure>\n\n<p>变量a的声明“提升”到顶部，此时还没赋值，所以打印出undefined。</p>\n<p>函数提升</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">b() </span><br><span class=\"line\">function b()&#123;</span><br><span class=\"line\">\tconsole.log(&#x27;b&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面的代码能够正常执行，说明存在函数提升，需要注意的是，var b &#x3D; function(){}这种形式声明一个函数属于变量提升，下面的代码将会报错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">b()</span><br><span class=\"line\">var b = function()&#123;</span><br><span class=\"line\">\tconsole.log(&#x27;b&#x27;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>无论是变量提升还是函数提升都跟js的执行机制有关，发生提升的原因会在”javascript之执行栈”这篇文章中提及。</p>\n","categories":["技术","web前端","javascript"],"tags":["javascript变量提升"]},{"title":"javascript之执行栈","url":"/2022/03/16/javascript%E4%B9%8B%E6%89%A7%E8%A1%8C%E6%A0%88/","content":"<h5 id=\"什么是执行栈？\"><a href=\"#什么是执行栈？\" class=\"headerlink\" title=\"什么是执行栈？\"></a>什么是执行栈？</h5><p>要想搞清楚什么是执行栈，首先得了解什么是执行上下文。简单来讲，只要有js代码运行，它一定是运行在执行上下文中，也就是说执行上下文是js代码运行环境的抽象概念，它有三种类型：</p>\n<p>全局执行上下文：浏览器中的全局对象就是 <code>window </code>对象，<code>this</code> 指向这个全局对象。ps：它只有一个。</p>\n<p>函数执行上下文：函数被调用时创建的上下文，每次调用函数都会创建一个上下文。</p>\n<p>eval函数执行上下文：eval函数的执行上下文，它只存在于eval函数中。ps：eval函数不推荐使用。</p>\n<p>执行栈就是保存执行上下文的一种数据结构，他遵循LIFO原则，在js中，开始运行代码时，会创建一个全局执行上下文，压入执行栈中，紧接着每遇到一个函数就会创建一个函数执行上下文，继续压入执行栈。js引擎会执行栈顶的函数，执行完将其弹出栈，继续执行下一个在栈顶的函数，如此反复，直到执行栈为空。</p>\n<p>看下面代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log(&#x27;1&#x27;)</span><br><span class=\"line\">function a()&#123;</span><br><span class=\"line\">\tconsole.log(&#x27;a&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function b()&#123;</span><br><span class=\"line\"> a()</span><br><span class=\"line\"> console.log(&#x27;b&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">b()</span><br><span class=\"line\">console.log(&#x27;2&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p>首先是创建全局执行上下文压入栈中并执行，输入‘’1“，然后遇到函数b被调用，此时创建函数执行上下文压入执行栈，执行b函数，遇到函数a被调用，又创建一个函数执行上下文压入栈中，执行a函数，输出‘a’,函数a执行完毕，弹出栈，接着执行函数b,输出‘b’,函数b执行完毕，弹出栈，接下来就是全局上下文，输出2，执行完毕，栈为空。</p>\n<p>说道这里，必须要补充一个概念：上下文周期</p>\n<p>执行上下文分为三个阶段：创建阶段、执行阶段和回收阶段。</p>\n<h5 id=\"创建阶段\"><a href=\"#创建阶段\" class=\"headerlink\" title=\"创建阶段\"></a>创建阶段</h5><p>就是函数被调用，但是其内部代码被执行之前，这个阶段主要：</p>\n<p>1、确定this的指向。</p>\n<p>2、创建词法环境LexicalEnvironment</p>\n<p>3、创建变量环境VarialEnvironment</p>\n<p>伪代码表示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ExectionContext = &#123;</span><br><span class=\"line\">\tthis:&#123;&#125;,//this在代码执行是才被确认的值</span><br><span class=\"line\">\tLexicalEnvironment:&#123;&#125;,//词法环境</span><br><span class=\"line\">\tVarialEnvironment:&#123;&#125;//变量环境</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>词法环境</p>\n<p>词法环境由两个部分组成：</p>\n<ul>\n<li>全局环境：是一个没有外部环境的词法环境，其外部环境引用为<code> null</code>，有一个全局对象，<code>this</code> 的值指向这个全局对象</li>\n<li>函数环境：用户在函数中定义的变量被存储在环境记录中，包含了<code>arguments</code> 对象，外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境</li>\n</ul>\n<p>伪代码表示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">GlobalExectionContext = &#123;  // 全局执行上下文</span><br><span class=\"line\">  LexicalEnvironment: &#123;       // 词法环境</span><br><span class=\"line\">    EnvironmentRecord: &#123;     // 环境记录</span><br><span class=\"line\">      Type: &quot;Object&quot;,           // 全局环境</span><br><span class=\"line\">      // 标识符绑定在这里 </span><br><span class=\"line\">      outer: &lt;null&gt;           // 对外部环境的引用</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FunctionExectionContext = &#123; // 函数执行上下文</span><br><span class=\"line\">  LexicalEnvironment: &#123;     // 词法环境</span><br><span class=\"line\">    EnvironmentRecord: &#123;    // 环境记录</span><br><span class=\"line\">      Type: &quot;Declarative&quot;,      // 函数环境</span><br><span class=\"line\">      // 标识符绑定在这里      // 对外部环境的引用</span><br><span class=\"line\">      outer: &lt;Global or outer function environment reference&gt;  </span><br><span class=\"line\">  &#125;  </span><br></pre></td></tr></table></figure>\n\n<p>变量环境</p>\n<p>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性</p>\n<p>在 ES6 中，词法环境和变量环境的区别在于前者用于存储函数声明和变量（ <code>let</code> 和 <code>const</code> ）绑定，而后者仅用于存储变量（ <code>var</code> ）绑定。上下文创建阶段，会在代码中扫描变量和函数声明，然后将函数声明存储在环境中，但变量会被初始化为<code>undefined</code>(<code>var</code>声明的情况下)和保持<code>uninitialized</code>(未初始化状态)(使用<code>let</code>和<code>const</code>声明的情况下)。这也是var声明的变量和函数声明存在提升的实际原因。</p>\n<h5 id=\"执行阶段\"><a href=\"#执行阶段\" class=\"headerlink\" title=\"执行阶段\"></a>执行阶段</h5><p>在这阶段，执行变量赋值、代码执行</p>\n<p>如果 <code>Javascript</code> 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 <code>undefined</code> 值</p>\n<h5 id=\"回收阶段\"><a href=\"#回收阶段\" class=\"headerlink\" title=\"回收阶段\"></a>回收阶段</h5><p>出栈等待虚拟机回收释放占用的内存。</p>\n","categories":["技术","web前端"],"tags":["javascript","js","js执行栈"]},{"title":"前端知识问答(三)","url":"/2022/05/14/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E4%B8%89/","content":"<h5 id=\"响应式和自适应分别是什么？有什么区别？\"><a href=\"#响应式和自适应分别是什么？有什么区别？\" class=\"headerlink\" title=\"响应式和自适应分别是什么？有什么区别？\"></a>响应式和自适应分别是什么？有什么区别？</h5><p>首先看看它们分别是什么：</p>\n<p>自适应：自适应布局就是指为了使网页适应的显示在不同大小终端设备上的新网页设计方式及技术，它需要开发多套界面来适应不同的终端。</p>\n<p>响应式：响应式布局就是实现不同屏幕分辨率的终端上浏览网页的不同展示方式。通过响应式设计能使网站在手机和平板电脑上有更好的浏览阅读体验。换句话说就是一个网站能够兼容多个终端，而不是为了每一个终端做一个特定的版本。</p>\n<p>它们之前的区别是：</p>\n<p>自适应布局：通过检测视口分辨率，来判断当前访问的设备是：pc端、平板、手机，从而请求服务层，返回不同的页面。</p>\n<p>响应式布局：通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容。</p>\n<h5 id=\"前端如何实现动画？\"><a href=\"#前端如何实现动画？\" class=\"headerlink\" title=\"前端如何实现动画？\"></a>前端如何实现动画？</h5><p>web前端实现动画的方式一般有：</p>\n<p>1、通过css中的transition、animation这些新特性</p>\n<p>2、通过js操作dom</p>\n<p>3、通过图片，gif&#x2F;png</p>\n<p>4、通过canvas和svg</p>\n<h5 id=\"vue2和vue3的区别？\"><a href=\"#vue2和vue3的区别？\" class=\"headerlink\" title=\"vue2和vue3的区别？\"></a>vue2和vue3的区别？</h5><p><a class=\"link\"   href=\"https://blog.csdn.net/qq_42883190/article/details/123526556\" >vue2和vue3的区别<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h5 id=\"node和浏览器的事件循环机制有什么不同？\"><a href=\"#node和浏览器的事件循环机制有什么不同？\" class=\"headerlink\" title=\"node和浏览器的事件循环机制有什么不同？\"></a>node和浏览器的事件循环机制有什么不同？</h5><p><a class=\"link\"   href=\"https://github.com/febobo/web-interview/issues/167\" >说说对Nodejs中事件循环机制的理解<i class=\"fas fa-external-link-alt\"></i></a></p>\n<p><a class=\"link\"   href=\"https://github.com/febobo/web-interview/issues/73\" >说说你对事件循环的理解<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h5 id=\"宏任务？微任务？\"><a href=\"#宏任务？微任务？\" class=\"headerlink\" title=\"宏任务？微任务？\"></a>宏任务？微任务？</h5><p><a class=\"link\"   href=\"https://zhuanlan.zhihu.com/p/78113300\" >js中的宏任务和微任务<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h5 id=\"canvas\"><a href=\"#canvas\" class=\"headerlink\" title=\"canvas\"></a>canvas</h5><p>这是一个很尴尬的问题，类似的还有谈谈xxx，这类问题可以从“是什么”、“怎么做”两个维度来回答</p>\n<p><a class=\"link\"   href=\"https://blog.csdn.net/qq_41361668/article/details/124088427\" >canvas<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h5 id=\"es6增加了哪些新特性？\"><a href=\"#es6增加了哪些新特性？\" class=\"headerlink\" title=\"es6增加了哪些新特性？\"></a>es6增加了哪些新特性？</h5><p><a class=\"link\"   href=\"https://www.jianshu.com/p/c0b4ffda1b2a\" >es6新特性<i class=\"fas fa-external-link-alt\"></i></a></p>\n<p><a class=\"link\"   href=\"https://blog.csdn.net/qq_56966124/article/details/124264185\" >es6的一些新特性，一篇就够了<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h5 id=\"页面的重排和重绘？\"><a href=\"#页面的重排和重绘？\" class=\"headerlink\" title=\"页面的重排和重绘？\"></a>页面的重排和重绘？</h5><p><a class=\"link\"   href=\"https://blog.csdn.net/zyansocute/article/details/123840079\" >简单易懂之什么是重绘和重排<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h5 id=\"讲讲前端性能优化？\"><a href=\"#讲讲前端性能优化？\" class=\"headerlink\" title=\"讲讲前端性能优化？\"></a>讲讲前端性能优化？</h5><p><a href=\"https://pointwong.github.io/2022/04/02/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/\">看这里</a></p>\n<h5 id=\"长连接、短连接，长轮训、短轮训、sse、websocket\"><a href=\"#长连接、短连接，长轮训、短轮训、sse、websocket\" class=\"headerlink\" title=\"长连接、短连接，长轮训、短轮训、sse、websocket\"></a>长连接、短连接，长轮训、短轮训、sse、websocket</h5><p><a class=\"link\"   href=\"https://blog.csdn.net/jiang_jin3323/article/details/124713243\" >长连接短连接长轮训短轮训<i class=\"fas fa-external-link-alt\"></i></a></p>\n<p><a class=\"link\"   href=\"https://blog.csdn.net/ck2580/article/details/120864923\" >sse、websocket<i class=\"fas fa-external-link-alt\"></i></a></p>\n","categories":["面试"],"tags":["面试题"]},{"title":"typescript之装饰器","url":"/2022/06/07/typescript%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8/","content":"<p>众所周知，typescript就是type + js，它是javascript的超级，不仅有类型约束，还实现了ECMAScript的一些新标准特性甚至一些处于草案阶段的特性，本文要讲到的装饰器就是其中之一。</p>\n<h5 id=\"首先什么是装饰器？\"><a href=\"#首先什么是装饰器？\" class=\"headerlink\" title=\"首先什么是装饰器？\"></a>首先什么是装饰器？</h5><p>装饰器是一种特殊类型的声明，它能够被附加到[类声明]，[方法]， [访问符]，[属性]或[参数]上。 装饰器使用 <code>@expression</code>这种形式，<code>expression</code>求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。</p>\n<p>下面定义一个装饰器 @color</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function color(target)&#123;</span><br><span class=\"line\">\t//do something</span><br><span class=\"line\">\tconsole.log(&#x27;color decorator&#x27;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后这样使用装饰器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@color</span><br><span class=\"line\">function dofunc()&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>装饰器组合作用于同一个声明上时，有两种书写方式：</p>\n<p>在一行上</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@a @b xxx</span><br></pre></td></tr></table></figure>\n\n<p>多行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@a</span><br><span class=\"line\">@b</span><br><span class=\"line\">xxx</span><br></pre></td></tr></table></figure>\n\n<p>装饰器装饰不同对象，表现不一样</p>\n<h5 id=\"类装饰器\"><a href=\"#类装饰器\" class=\"headerlink\" title=\"类装饰器\"></a>类装饰器</h5><p>类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。</p>\n<p>下面定义一个类装饰器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function seal(constructor:Function)&#123;</span><br><span class=\"line\">\tObject.seal(constructor);</span><br><span class=\"line\">\tObject.seal(constructor.prototype)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@seal</span><br><span class=\"line\">class hello &#123;</span><br><span class=\"line\">\tconstructor()&#123;</span><br><span class=\"line\">\t\t// do sth</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"方法装饰器\"><a href=\"#方法装饰器\" class=\"headerlink\" title=\"方法装饰器\"></a>方法装饰器</h5><p>(未完待续)</p>\n","tags":["ts","typescript"]}]