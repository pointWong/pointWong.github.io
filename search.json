[{"title":"最近一些面试总结","url":"/2022/04/02/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/","content":"<p>三月下旬，陆陆续续面试了一些公司，发现这些公司技术面的时候所问的问题基本都差不多。为了巩固这方面的知识，同时希望给看到的同学带来一些帮助，做了一下总结，尝试解答或者贴上其他人的回答。</p>\n<h5 id=\"1、说活对js-x2F-node的事件循环机制\"><a href=\"#1、说活对js-x2F-node的事件循环机制\" class=\"headerlink\" title=\"1、说活对js&#x2F;node的事件循环机制\"></a>1、说活对js&#x2F;node的事件循环机制</h5><p>这个问题出现频率还是挺高的，主要考察面试者对js这门语言认识的深度，理解它的执行机制。在github上已经有人回答得很具体了：</p>\n<p><a class=\"link\"   href=\"https://github.com/febobo/web-interview/issues/167\" >说说对Nodejs中事件循环机制的理解<i class=\"fas fa-external-link-alt\"></i></a></p>\n<p><a class=\"link\"   href=\"https://github.com/febobo/web-interview/issues/73\" >说说你对事件循环的理解<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h5 id=\"2、new-具体做了什么，如何实现一个new？\"><a href=\"#2、new-具体做了什么，如何实现一个new？\" class=\"headerlink\" title=\"2、new 具体做了什么，如何实现一个new？\"></a>2、new 具体做了什么，如何实现一个new？</h5><p><a class=\"link\"   href=\"https://github.com/febobo/web-interview/issues/69\" >这是答案<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h5 id=\"3、说说微前端架构\"><a href=\"#3、说说微前端架构\" class=\"headerlink\" title=\"3、说说微前端架构\"></a>3、说说微前端架构</h5><p>微前端其实是借鉴了微服务的概念，微服务大家都知道:后端(根据业务层次)分拆代码并形成独立的库，每个代码库负责自己的业务逻辑，并公开api，独立部署，分由不同团队维护。微前端借鉴了这种做法，把前段项目按照业务分拆成更小的单元，这些单元分由不同人员或团队开发维护，单独部署，其核心思想是远程应用程序和运行时加载。</p>\n<p>参考 <a class=\"link\"   href=\"https://zhuanlan.zhihu.com/p/414468874\" >深入解析微前端乾坤原理<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h5 id=\"4、实现一个三栏布局\"><a href=\"#4、实现一个三栏布局\" class=\"headerlink\" title=\"4、实现一个三栏布局\"></a>4、实现一个三栏布局</h5><p>三栏布局有很多种方法：利用绝对定位、浮动、bfc，flex、table等都可以实现</p>\n<p>具体可参考 <a class=\"link\"   href=\"https://zhuanlan.zhihu.com/p/25070186\" >https://zhuanlan.zhihu.com/p/25070186<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h5 id=\"5、哪些css属性会自动继承，哪些不会？具体讲讲\"><a href=\"#5、哪些css属性会自动继承，哪些不会？具体讲讲\" class=\"headerlink\" title=\"5、哪些css属性会自动继承，哪些不会？具体讲讲\"></a>5、哪些css属性会自动继承，哪些不会？具体讲讲</h5><p>字体、文本、可见性属性(opacity visibility)等大多是自动继承属性；盒子模型、背景、定位、生成内容(如content)、轮廓等一般是无继承属性。需要注意：a标签的字体颜色不能被继承，h1-h6的字体大小也不能被继承。</p>\n<h5 id=\"6、什么是bfc\"><a href=\"#6、什么是bfc\" class=\"headerlink\" title=\"6、什么是bfc\"></a>6、什么是bfc</h5><p>bfc即块级格式化上下文，它会形成相对于其容器外一个独立的空间，其内部的子元素不会影响到外部的元素，同时不会和float的元素重叠。bfc可应用于防止margin坍塌、实现多栏布局、清除浮动等场景。触发bfc的条件&#x2F;属性：html、float、值不为visible的overflow、display为inline-block、table、inline-table、table-cell、table-caption、flex、inline-flex、grid、inline-grid.</p>\n<h5 id=\"7、关于webpack，如何编写一个loader和plugin\"><a href=\"#7、关于webpack，如何编写一个loader和plugin\" class=\"headerlink\" title=\"7、关于webpack，如何编写一个loader和plugin\"></a>7、关于webpack，如何编写一个loader和plugin</h5><p>1、关于loader</p>\n<p>由于webpack只能处理js文件，对于其他类型的文件需要专门的转换器处理一下再传入webpack，这个转换器就是loader。它对模块的源代码进行转换，将文件从不同的语言转换为JavaScript，也可将图像转换为data URL。loader其实就是一个函数，接受源模块，把处理结果传给下一个loader或webpack。</p>\n<p>下面来看看如何编写一个loader：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//一个把alert转为console.log的简单的loader</span><br><span class=\"line\">/loaders/alertToConsole.js</span><br><span class=\"line\">mudule.exports = function(source)&#123;</span><br><span class=\"line\">\t//source是webpack传入的源代码</span><br><span class=\"line\">\treturn source.replace(&#x27;alert&#x27;,&#x27;console.log&#x27;)//把alert转为console.log</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在webpack中配置该loader</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mudule:&#123;</span><br><span class=\"line\">\trules:[</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttest:/\\.js/,</span><br><span class=\"line\">\t\t\tuse:[</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tloader:path.resolve(_dirname,&#x27;./loaders/alertToConsole.js&#x27;)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，项目中所有js文件中的alert就都会被转成console.log了。当然，如果要实现一些复杂的功能可能要先把源代码转为ast，也就是抽象语法树，可以将其看成树形js对象，通过遍历ast树可以做一些复杂的操作，最后再转化成目标代码返回。</p>\n<p>2、关于plugin</p>\n<p>webpack的生命周期中会广播出很多事件，plugin可以监听这些事件，在合适的时间通过webpack的api去改变输出结果。</p>\n<p>一个简单的plugin的结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class myPlugin&#123;</span><br><span class=\"line\">\tconstructor(options)&#123;</span><br><span class=\"line\">\t\tconsole.log(&#x27;my plugin options&#x27;,options)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tapply(compiler)&#123;</span><br><span class=\"line\">\t\tcompiler.plugin(&#x27;done&#x27;,compilation=&gt;&#123;</span><br><span class=\"line\">\t\t\tdo something</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = myPlugin;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子中，可以把plugin看成带有apply方法的类。compiler代表webpack的整个生命周期，compilation代表依次新的编译过程。两者都暴露了钩子，可根据这些钩子编写一个满足实际需求的插件。</p>\n<p>下面实现一个简单的需求：生成打包文件之后输出一个包含“文件打包完毕”的.txt文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/plugins/txtPlugin.js</span><br><span class=\"line\">class txtPlugin&#123;</span><br><span class=\"line\">\tconstructor(options)&#123;</span><br><span class=\"line\">\t\tthis.options = options</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tapply(compiler)&#123;</span><br><span class=\"line\">\t\tcompiler.plugin(&#x27;done&#x27;,(compilation,callback)=&gt;&#123;</span><br><span class=\"line\">\t\t\tlet words &#x27;文件打包完毕&#x27;</span><br><span class=\"line\">\t\t\tcompilation.assets[&#x27;xxx.txt&#x27;]=&#123;</span><br><span class=\"line\">\t\t\t\tsource:function()&#123;</span><br><span class=\"line\">\t\t\t\t\treturn words</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\tsize:function()&#123;</span><br><span class=\"line\">\t\t\t\t\treturn words.length</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcallback()</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = txtPlugin</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const txtPlugin = require(&#x27;/plugins/txtPlugin.js&#x27;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">\tplugins:[</span><br><span class=\"line\">\t\tnew txtPlugin()</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、loader和plugin的区别</p>\n<p>loader遵循单一原则，只能做一件事，比如sass-loader,只能解析sass&#x2F;scss文件,而plugin是针对整个流程的，在这个流程中可以广泛地执行任务。</p>\n<h5 id=\"8、axios请求撤销，重连\"><a href=\"#8、axios请求撤销，重连\" class=\"headerlink\" title=\"8、axios请求撤销，重连\"></a>8、axios请求撤销，重连</h5><p>撤销主要是利用axios.CancelToken，axios官网介绍了两种使用方法：</p>\n<p>方法一（多用于取消单个接口）：</p>\n<p>通过传入一个执行函数到CancelToken构造函数来创建一个cancel token</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import axios from &#x27;axios&#x27;</span><br><span class=\"line\">let cancel</span><br><span class=\"line\">export function getSth()&#123;</span><br><span class=\"line\">\treturn axios(&#123;</span><br><span class=\"line\">\t\turl:&#x27;/abc&#x27;，</span><br><span class=\"line\">\t\tmethod:&#x27;get&#x27;.</span><br><span class=\"line\">\t\tcancelToken:new axios.CancelToken(funtion executor(c)&#123;</span><br><span class=\"line\">\t\t\tcancel = c</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要取消的时候，直接调用cancel即可</p>\n<p>方法二（撤销多个请求）：</p>\n<p>使用CancelToken.source工厂方法创建一个cancel token。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import axios from &#x27;axios&#x27;</span><br><span class=\"line\">const CancelToken = axios.CancelToken</span><br><span class=\"line\">const source = CancelToken.source()</span><br><span class=\"line\">export function getSth()&#123;</span><br><span class=\"line\">\treturn axios(&#123;</span><br><span class=\"line\">\t\turl:&#x27;/abc&#x27;,</span><br><span class=\"line\">\t\tmethod:&#x27;get&#x27;,</span><br><span class=\"line\">\t\tcancelToken:source.token</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>取消调用source.cancel()</p>\n<p>关于重连，即网络出现不佳或者请求失败的重新连接机制。</p>\n<p>axios的重连可通过响应拦截器来实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">request.interceptors.response.use(</span><br><span class=\"line\">\tresponse =&gt;response.data || &#123;&#125;,</span><br><span class=\"line\">\terr =&gt;&#123;</span><br><span class=\"line\">\t\tlet config = err.config</span><br><span class=\"line\">\t\tif(!config) return Promise.reject(err)</span><br><span class=\"line\">\t\tconfig._retryCount = config._retryCount || 0</span><br><span class=\"line\">\t\t//设置重连3次</span><br><span class=\"line\">\t\tif(config._retryCount&gt;3)return Promise.reject(err)</span><br><span class=\"line\">\t\tconfig.retryCount++</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t//2s延迟发起新请求</span><br><span class=\"line\">\t\tlet newReq= new Promise((rs)=&gt;&#123;</span><br><span class=\"line\">\t\t\tsetTimeout(()=&gt;&#123;</span><br><span class=\"line\">\t\t\t\trs()</span><br><span class=\"line\">\t\t\t&#125;,2000)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t\t//返回新的axios请求</span><br><span class=\"line\">\t\treturn newReq.then(function()&#123;</span><br><span class=\"line\">\t\t\treturn request(config)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"9、sass-x2F-less-x2F-stylus如何实现主题切换\"><a href=\"#9、sass-x2F-less-x2F-stylus如何实现主题切换\" class=\"headerlink\" title=\"9、sass&#x2F;less&#x2F;stylus如何实现主题切换\"></a>9、sass&#x2F;less&#x2F;stylus如何实现主题切换</h5><p>基本的思路：把不同主题的样式代码打包在一起，通过不同的主题class来实现主题切换。这个class可以加载body上或者根组件上，也可以加载到具体的元素或者更小的模块上。</p>\n<p>下面看看sass的实现</p>\n<p>首先，创建一个theme.scss文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$light&#123;</span><br><span class=\"line\">\tprimaryColor:white;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">$dark&#123;</span><br><span class=\"line\">\tprimaryColor:black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$themes:&#123;</span><br><span class=\"line\">\tlight:$light,</span><br><span class=\"line\">\tdark:$dark</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后创建一个themify.scss</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@import &#x27;./theme.scss&#x27;</span><br><span class=\"line\">@mixin themify($themes:$themes)&#123;</span><br><span class=\"line\">\t@each $them-name,$theme-map in $themes &#123;</span><br><span class=\"line\">\t\t$theme-map:$theme-map !global //局部变量提升为全局变量</span><br><span class=\"line\">\t\tbody[data-theme=#&#123;$theme-name&#125;] &amp; &#123;</span><br><span class=\"line\">\t\t\t@content;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@function themed($key)&#123;</span><br><span class=\"line\">\t@return map-get($theme-map,$key)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@import &#x27;/themify.scss&#x27;</span><br><span class=\"line\">.container&#123;</span><br><span class=\"line\">\t@include themify($themes)&#123;</span><br><span class=\"line\">\t\tcolor:themed(&#x27;primaryColor&#x27;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"10、object-assign和…拓展符的区别\"><a href=\"#10、object-assign和…拓展符的区别\" class=\"headerlink\" title=\"10、object.assign和…拓展符的区别\"></a>10、object.assign和…拓展符的区别</h5><p>本质上没有区别，object.assign等同于…拓展符。</p>\n<h5 id=\"11、谈谈promise\"><a href=\"#11、谈谈promise\" class=\"headerlink\" title=\"11、谈谈promise\"></a>11、谈谈promise</h5><p>Promise是一种比较常用的异步编程方案。它有三种状态：</p>\n<p>pending，fulfiled，rejected，分别表示等待，完成，失败。状态的改变只有两种pending-&gt;fulfiled,pending-&gt;rejected,这个过程是不可逆的。创建一个Promise实例时需要传入一个函数，这个函数的入参分别是resolve和reject两个函数，用来修改promise的状态。执行resolve后状态为fulfiled，执行reject后状态改为rejected，举个常见的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const p1= new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">\tsetTimeout(()=&gt;&#123;</span><br><span class=\"line\">\t\tif(isGood)&#123;</span><br><span class=\"line\">\t\t\tresolve(&#x27;成功了&#x27;)</span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\treject(&#x27;失败了&#x27;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>然后通过链式调用的方式去处理状态变更后的结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">p1.then(res=&gt;&#123;dosth&#125;)</span><br><span class=\"line\">.catch(err=&gt;&#123;dosth&#125;)</span><br><span class=\"line\">.finally(data=&gt;&#123;dosth&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>Promise还提供了一些静态方法，用于做一些其他有趣的处理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Promise.all([p1,p2,p3,...])</span><br></pre></td></tr></table></figure>\n\n<p>该方法接受一个promise组成的数组,所有的promise对象都成功才会触发fulfiled，只要有一个失败就会触发rejected</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Promise.allSettled([p1,p2,p3,...])</span><br></pre></td></tr></table></figure>\n\n<p>只要所有的promise都settled(fulfiled或rejected)，返回一个promise，携带一个对象数组，每个对象对应各个promise的结果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Promise.race([p1,p2,p3,...])</span><br></pre></td></tr></table></figure>\n\n<p>返回一个promise，只要有一个promise的状态改为fulfiled或rejected，则立即触发其自身的fulfied或者rejected。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Promise.resolve(value)</span><br></pre></td></tr></table></figure>\n\n<p>返回一个状态有给定value决定的promise对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Promise.reject(error)</span><br></pre></td></tr></table></figure>\n\n<p>返回一个状态为失败的promise对象。</p>\n<h5 id=\"12、vuex的原理，如何按需加载\"><a href=\"#12、vuex的原理，如何按需加载\" class=\"headerlink\" title=\"12、vuex的原理，如何按需加载\"></a>12、vuex的原理，如何按需加载</h5><p>vuex是vuejs专用状态管理工具，采用集中式存储管理所有组件的状态，并保证状态以一种可预测的方式改变。</p>\n<p>它由以下几个部分组成：</p>\n<p><strong>state</strong></p>\n<p>单一存储状态，存储基本数据</p>\n<p><strong>getters</strong></p>\n<p>是计算属性，类似vue实例中的computed</p>\n<p><strong>mutations</strong></p>\n<p>state的更改在这里处理</p>\n<p><strong>actions</strong></p>\n<p>提交mutation去更改数据，往往包含异步操作。</p>\n<p><strong>module</strong></p>\n<p>分割模块，每个模块拥有独立的state、getters、mutantions、actions</p>\n<p>除此之外，vuex还提供了mapState,mapGetters.mapMutation,mapActions等函数，使得开发者在vm中更加方便地处理store.</p>\n<p>vuex和vue实例绑定是借助mixin，在初始化阶段之前把store注册到vue组件实例，并注册引用$store。借助vue的data实现state的响应，借助computed实现getters的实时监听。</p>\n<p>vuex按需加载，有时候我们进入首页，并不需要所有的vuex里面维护的状态，只需要加载首页用到的状态即可，这个时候就可以利用vuex提供的registerModule来按需异步加载不同的vuex模块。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if(isNeedVuexModule)&#123;</span><br><span class=\"line\">\timport(&#x27;./store/modules/&#x27;+moduleName).then(res=&gt;&#123;</span><br><span class=\"line\">\t\tthis.$store.registerModule(moduleName,res.default)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"13、路由-x2F-按钮权限控制是怎么做的\"><a href=\"#13、路由-x2F-按钮权限控制是怎么做的\" class=\"headerlink\" title=\"13、路由&#x2F;按钮权限控制是怎么做的\"></a>13、路由&#x2F;按钮权限控制是怎么做的</h5><p>参考 <a class=\"link\"   href=\"https://juejin.cn/post/6844903933429678094\" >https://juejin.cn/post/6844903933429678094<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h5 id=\"14、vue中是如何监听数组的改变的\"><a href=\"#14、vue中是如何监听数组的改变的\" class=\"headerlink\" title=\"14、vue中是如何监听数组的改变的\"></a>14、vue中是如何监听数组的改变的</h5><p>vue2在原因层面不支持用Object.defineProperty监听不存在的数组元素，并且通过一些能造成数组改变的方法也不能被监听到。vue2中重写了push，pop，shift，unshift，aplice.sort,reverse这七个数组方法，数组在执行这几个方法是手动触发响应页面的效果。至于为什么不去监听数组中已存在元素的变化，可参考：<a class=\"link\"   href=\"https://github.com/vuejs/vue/issues/8562\" >https://github.com/vuejs/vue/issues/8562<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h5 id=\"15、谈谈vue-extend的作用\"><a href=\"#15、谈谈vue-extend的作用\" class=\"headerlink\" title=\"15、谈谈vue.extend的作用\"></a>15、谈谈vue.extend的作用</h5><p>Vue提供的一个构造器，用于创建一个子类，参数是一个包含组件选型的对象，</p>\n<p>注意：Vue.extend创建的是一个构造器，而不是一个组件实例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//html</span><br><span class=\"line\">&lt;div id=&#x27;id&#x27;&gt;&lt;/div&gt;</span><br><span class=\"line\">//js</span><br><span class=\"line\">//创建构造器</span><br><span class=\"line\">var Child = Vue.extend(&#123;</span><br><span class=\"line\">\ttemplate:&#x27;&lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt;&#x27;,</span><br><span class=\"line\">\tdata()&#123;</span><br><span class=\"line\">\t\treturn&#123;</span><br><span class=\"line\">\t\t\tname:&#x27;Brian&#x27;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">new Child().$mount(&#x27;#id&#x27;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"16、http状态码\"><a href=\"#16、http状态码\" class=\"headerlink\" title=\"16、http状态码\"></a>16、http状态码</h5><p>常见的http状态码：</p>\n<ul>\n<li>1表示消息 100临时相应，需要客户端继续发送请求 101 服务器根据客户端请求切换协议 主要用于websoket或http2升级</li>\n<li>2表示成功 200表示成功 201表示创建了新的资源 202 表示服务器已经接受了请求 单位处理 204服务器成功处理但不返回任何内容 206 表示处理了部分请求</li>\n<li>表示重定向 301&#x2F;308永久重定向 302&#x2F;307临时 304表示使用缓存</li>\n<li>4表示请求错误 400错误语法 401未授权 403服务器拒绝 404未找到 407需要代理 408超时</li>\n<li>5表示服务器错误 500服务器内部错误 502网关错误 504网关超时 505 http版本的问题</li>\n</ul>\n<h5 id=\"17、link标签的行内属性-deffer和async的含义和区别\"><a href=\"#17、link标签的行内属性-deffer和async的含义和区别\" class=\"headerlink\" title=\"17、link标签的行内属性 deffer和async的含义和区别\"></a>17、link标签的行内属性 deffer和async的含义和区别</h5><p>当script标签设置这两个行内属性后，js文件将会异步加载，不会阻塞dom的渲染。</p>\n<p>它们的区别是：defer会在endanger渲染完成后DOMContentLoaded之前按照顺序执行。而async只要加载完就会立即执行</p>\n<h5 id=\"18、js如何比较两个对象是否相等\"><a href=\"#18、js如何比较两个对象是否相等\" class=\"headerlink\" title=\"18、js如何比较两个对象是否相等\"></a>18、js如何比较两个对象是否相等</h5><p>通过遍历一层一层比较值是否相等，当前层遇到对象，则继续遍历，直到最深一层的值为基本类型。</p>\n<h5 id=\"19、移动端的适配\"><a href=\"#19、移动端的适配\" class=\"headerlink\" title=\"19、移动端的适配\"></a>19、移动端的适配</h5><p>参考 <a class=\"link\"   href=\"https://www.jianshu.com/p/b13d811a6a76\" >https://www.jianshu.com/p/b13d811a6a76<i class=\"fas fa-external-link-alt\"></i></a></p>\n<h5 id=\"20、es6的继承\"><a href=\"#20、es6的继承\" class=\"headerlink\" title=\"20、es6的继承\"></a>20、es6的继承</h5><p>extends</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// es6继承</span><br><span class=\"line\">  class Animal &#123;</span><br><span class=\"line\">    //构造函数，里面写上对象的属性</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">      this.name = props.name || &#x27;Unknown&#x27;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //方法写在后面</span><br><span class=\"line\">    eat() &#123;//父类共有的方法</span><br><span class=\"line\">      console.log(this.name + &quot; will eat pests.&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //class继承</span><br><span class=\"line\">  class Bird extends Animal &#123;</span><br><span class=\"line\">    //构造函数</span><br><span class=\"line\">    constructor(props,myAttribute) &#123;//props是继承过来的属性，myAttribute是自己的属性</span><br><span class=\"line\">      //调用实现父类的构造函数</span><br><span class=\"line\">      super(props)//相当于获得父类的this指向</span><br><span class=\"line\">      this.type = props.type || &quot;Unknown&quot;;//父类的属性，也可写在父类中</span><br><span class=\"line\">      this.attr = myAttribute;//自己的私有属性</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fly() &#123;//自己私有的方法</span><br><span class=\"line\">      console.log(this.name + &quot; are friendly to people.&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    myattr() &#123;//自己私有的方法</span><br><span class=\"line\">      console.log(this.type+&#x27;---&#x27;+this.attr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//通过new实例化</span><br><span class=\"line\">  var myBird = new Bird(&#123;</span><br><span class=\"line\">    name: &#x27;小燕子&#x27;,</span><br><span class=\"line\">    type: &#x27;Egg animal&#x27;//卵生动物</span><br><span class=\"line\">  &#125;,&#x27;Bird class&#x27;)</span><br><span class=\"line\">  myBird.eat()</span><br><span class=\"line\">  myBird.fly()</span><br><span class=\"line\">  myBird.myattr()</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"21、webapp如何做缓存\"><a href=\"#21、webapp如何做缓存\" class=\"headerlink\" title=\"21、webapp如何做缓存\"></a>21、webapp如何做缓存</h5><p>serviceWorker,ApplicationCache ,LocalStorage,indexedDb</p>\n<h5 id=\"22、ts中函数重载的概念？应用场景？\"><a href=\"#22、ts中函数重载的概念？应用场景？\" class=\"headerlink\" title=\"22、ts中函数重载的概念？应用场景？\"></a>22、ts中函数重载的概念？应用场景？</h5><p>ts函数重载就是同一个函数提供多个函数类型，它的意义在于让你清晰的知道，传入不同的参数得到不同的结果，这也是它的应用场景。</p>\n<h5 id=\"23、普通函数和箭头函数的区别\"><a href=\"#23、普通函数和箭头函数的区别\" class=\"headerlink\" title=\"23、普通函数和箭头函数的区别\"></a>23、普通函数和箭头函数的区别</h5><ul>\n<li>箭头函数没有arguments绑定，取而代之用rest参数…解决。但是，箭头函数可以访问最近的非箭头函数的arguments对象。</li>\n<li>箭头函数没有自己的this，它的this在生命周期中是保持不变的，始终与最近的非箭头函数中的this的值绑定。</li>\n<li>箭头函数不能作为构造函数，也就是不能被new，</li>\n<li>箭头函数不能存在重复命名的参数</li>\n<li>箭头函数没有原型属性</li>\n<li>箭头函数不能当做Generator函数，不能使用yield关键字</li>\n</ul>\n<h5 id=\"24、weakSet和weakMap的应用场景\"><a href=\"#24、weakSet和weakMap的应用场景\" class=\"headerlink\" title=\"24、weakSet和weakMap的应用场景\"></a>24、weakSet和weakMap的应用场景</h5><ul>\n<li>weakSet的成员只能是对象，不能是其他类型。weakSet中的对象都是弱引用，因此垃圾回收机制不考虑weakSet对该对象的引用，如果其他对象不再引用该对象，垃圾回收机制将会自动回收该对象所占用的内存，而不考虑该对象还存在于weakSet中。使用场景：用来存储dom节点，而不用担心这些节点从文档移除会引发内存泄露。</li>\n<li>weakMap只能接受对象作为键名，不接受其他类型的值作为键名。weakMap同样不会妨碍垃圾回收机制。</li>\n<li>使用场景：在网页的dom元素上添加数据，就可以使用weakMap结构，当该dom元素别清楚，其对应的weakMap记录会被自动移除。</li>\n</ul>\n<h5 id=\"25、讲讲前端性能优化\"><a href=\"#25、讲讲前端性能优化\" class=\"headerlink\" title=\"25、讲讲前端性能优化\"></a>25、讲讲前端性能优化</h5><p>1、减少http请求</p>\n<p>2、使用http2</p>\n<p>3、使用服务端渲染</p>\n<p>4、静态资源使用cdn</p>\n<p>5、css放在文件头部，JavaScript放在文件底部，还有async和deffer的使用</p>\n<p>6、使用字体图标代替图片图标</p>\n<p>7、善用缓存，不重复加载相同的内容，cache-control, service worker</p>\n<p>8、压缩文件</p>\n<p>9、图片优化</p>\n<ul>\n<li>-图片延迟加载</li>\n<li>-响应式图片，使用picture media</li>\n<li>-调整图片大小</li>\n<li>-降低图片质量</li>\n<li>-尽可能利用css3效果代替图片</li>\n<li>-使用webp格式的图片</li>\n</ul>\n<p>10、代码按需加载</p>\n<p>11、减少页面重排重回</p>\n<ul>\n<li>-修改样式时不直接写样式，而是通过替换class来改变样式</li>\n<li>-先将dom元素脱离文档流，修改完之后再带回文档</li>\n</ul>\n<p>12、避免页面卡顿</p>\n<p>目前大多数设备的屏幕刷新率为 60 次&#x2F;秒。因此，如果在页面中有一个动画或渐变效果，或者用户正在滚动页面，那么浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致。 其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒&#x2F; 60 &#x3D; 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。</p>\n<p>13、使用requestAnimationFrame来实现视觉变化。</p>\n<p>由于大部分设备刷新频率为60次&#x2F;秒，每一帧的平均时间大概为16毫秒，js实现动画最好的情况就是在帧的开头开始执行，requestAnimationFrame正好可以满足这点</p>\n<p>14、使用webworker线程处理耗时操作</p>\n","categories":["技术"],"tags":["web前端","面试"]},{"title":"分享一款特别适合切图的截图工具","url":"/2020/12/20/%E5%88%86%E4%BA%AB%E4%B8%80%E6%AC%BE%E7%89%B9%E5%88%AB%E9%80%82%E5%90%88%E5%88%87%E5%9B%BE%E7%9A%84%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7/","content":"<p>推荐一款特别适合前端切图的截图工具。它的主要功能是截图、贴图和取色，由国人开发，完全免费，无广告，体积小却功能逆天，个人觉得是目前用过的最好用的截图工具。</p>\n<p>下载地址：</p>\n<p><a class=\"link\"   href=\"https://www.snipaste.com/\" >https://www.snipaste.com/<i class=\"fas fa-external-link-alt\"></i></a></p>\n<p>或者</p>\n<p>链接：<a class=\"link\"   href=\"https://pan.baidu.com/s/1klNDMibTT4rsKJ2ceu_coQ\" >https://pan.baidu.com/s/1klNDMibTT4rsKJ2ceu_coQ<i class=\"fas fa-external-link-alt\"></i></a><br>提取码：pyvz</p>\n","categories":["工具"],"tags":["截图工具"]},{"title":"electron从入门到入门","url":"/2020/04/04/electron%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/","content":"<h5 id=\"electron是什么\"><a href=\"#electron是什么\" class=\"headerlink\" title=\"electron是什么\"></a>electron是什么</h5><p>electron就是使用web技术创建跨平台原生桌面应用的框架。electron用web页面作为它的GUI，结合chromium、nodejs和用于调用操作系统本地功能的APIs. 可以把electron看成包含chromium和node的运行时环境，可以简单得理解成web运行在node上。</p>\n<h5 id=\"主进程、渲染进程\"><a href=\"#主进程、渲染进程\" class=\"headerlink\" title=\"主进程、渲染进程\"></a>主进程、渲染进程</h5><p>这是electron中比较重要的两个概念。主进程是运行package.json里main脚本的进程成为主进程，用来展示页面的进程成为渲染进程。这两个进程通过ipc模块进行通信。</p>\n<h5 id=\"第一个electron应用\"><a href=\"#第一个electron应用\" class=\"headerlink\" title=\"第一个electron应用\"></a>第一个electron应用</h5><p>1、初始化一个npm项目，安装electron</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm init -y &amp;&amp; npm i electron -D</span><br></pre></td></tr></table></figure>\n\n<p>2、创建index.js(主进程执行代码)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123;app,BrouserWindow&#125; = require(&#x27;electron&#x27;)</span><br><span class=\"line\">//创建全局变量，避免被gc</span><br><span class=\"line\">let win</span><br><span class=\"line\">function createWin()&#123;</span><br><span class=\"line\">\t//创建窗口，设置宽高</span><br><span class=\"line\">\twin = new BrowserWindow(&#123;width:1000,height:800&#125;)</span><br><span class=\"line\">\t//加载页面</span><br><span class=\"line\">\twin.loadFile(&#x27;./index.html&#x27;)</span><br><span class=\"line\">\twin.webContents.openDevTools()//打开开发者工具</span><br><span class=\"line\">\t//监听窗口关闭时间</span><br><span class=\"line\">\twin.on(&#x27;closed&#x27;,()=&gt;&#123;</span><br><span class=\"line\">\t\twin = null//取消引用</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//初始化</span><br><span class=\"line\">app.on(&#x27;ready&#x27;,createWindow)</span><br><span class=\"line\">//当关闭全部窗口时</span><br><span class=\"line\">app.on(&#x27;window-all-closed&#x27;,()=&gt;&#123;</span><br><span class=\"line\">\tif(process.platform !==&#x27;darwin&#x27;)&#123;</span><br><span class=\"line\">\t\tapp.quit()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.on(&#x27;activate&#x27;,()=&gt;&#123;</span><br><span class=\"line\">\tif(win === null)&#123;</span><br><span class=\"line\">\t\tcreateWindow()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>接下来创建一个简单的html页面</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//index.html</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">\t&lt;head&gt;</span><br><span class=\"line\">\t\t&lt;meta charset=&#x27;utf-8&#x27;&gt;</span><br><span class=\"line\">\t\t&lt;title&gt;first app&lt;/title&gt;</span><br><span class=\"line\">\t&lt;/head&gt;</span><br><span class=\"line\">\t&lt;body&gt;</span><br><span class=\"line\">\t\t&lt;div&gt;hello world&lt;/div&gt;</span><br><span class=\"line\">\t&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在package.json中scripts添加 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tmain:&#x27;index.js&#x27;，</span><br><span class=\"line\">\tscripts:&#123;</span><br><span class=\"line\">\t\t&#x27;dev&#x27;:&#x27;electron .&#x27;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>打开终端输入npm run dev,将会弹出刚刚的应用。</p>\n<h5 id=\"主进程和渲染进程的通信\"><a href=\"#主进程和渲染进程的通信\" class=\"headerlink\" title=\"主进程和渲染进程的通信\"></a><strong>主进程和渲染进程的通信</strong></h5><p><em>ipcMain和ipcRenderer</em></p>\n<p>ipcMain在主进程中使用，用来处理渲染进程发送的信息</p>\n<p>ipcRenderer在渲染进程中使用，用来发送消息给主进程，也可用来接收主进程的回复信息。</p>\n<p>主进程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123;ipcMain&#125; = require(&#x27;electron&#x27;)</span><br><span class=\"line\">//监听渲染进程发来的消息</span><br><span class=\"line\">ipcMain.on(&#x27;ping&#x27;,(e,data)=&gt;&#123;</span><br><span class=\"line\">\te.sender.send(&#x27;pong&#x27;,&#x27;main返回的值&#x27;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>渲染进程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123;ipcRenderer&#125; = require(&#x27;electron&#x27;)</span><br><span class=\"line\">//发送消息给主进程</span><br><span class=\"line\">ipcRenderer.send(&#x27;ping&#x27;,&#x27;传给main&#x27;)</span><br><span class=\"line\">//监听主进程发来的消息</span><br><span class=\"line\">ipcRenderer.on(&#x27;pong&#x27;,(e,data)=&gt;&#123;</span><br><span class=\"line\">\tconsole.log(data)//我是主进程返回的值</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><em>remote模块</em></p>\n<p>使用remote模块可以直接调用主进程对象的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123;dialog&#125; = require(&#x27;electron&#x27;).remote</span><br><span class=\"line\">dialog.showMessageBox(&#x27;你好，世界&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p><em>webContents</em></p>\n<p>webContents负责渲染和控制页面，是BrowserWindow的一个属性。我们可以使用它的send方法像渲染进程发送消息</p>\n<p>主进程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123;app,BrowserWindow&#125; = require(&#x27;electron&#x27;)</span><br><span class=\"line\">let win </span><br><span class=\"line\">app.on(&#x27;ready&#x27;,()=&#123;</span><br><span class=\"line\">\twin = new BrowserWindow(&#123;width:1000,height:800&#125;)</span><br><span class=\"line\">\twin.loadFile(&#x27;./index.html&#x27;)</span><br><span class=\"line\">\t//导航完成时触发</span><br><span class=\"line\">\twin.webContents.on(&#x27;dif-finish-load&#x27;,()=&gt;&#123;</span><br><span class=\"line\">\t\twin.webContents.send(&#x27;ping&#x27;,&#x27;send to renderer process&#x27;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>渲染进程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123;ipcRenderer&#125; = require(&#x27;electron&#x27;)</span><br><span class=\"line\">ipcRenderer.on(&#x27;ping&#x27;,(e,data)=&gt;&#123;</span><br><span class=\"line\">\tconsole.log(data)// send to renderer process</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>至此，你已经知道如何创建页面以及进程间通信，可以编写简单的electron应用了~~</p>\n","categories":["技术","electron"],"tags":["electron","桌面应用","跨平台"]},{"title":"css奇技淫巧之currentColor","url":"/2021/08/05/css%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%E4%B9%8BcurrentColor/","content":"<h5 id=\"currentColor\"><a href=\"#currentColor\" class=\"headerlink\" title=\"currentColor\"></a>currentColor</h5><p>相信不少前端同学没听过这个，也许会疑惑，css里面有这东西？哈哈，有的，它用来表示当前文字的颜色，不管当前文字的颜色是直接设置还是继承的。下面代码说明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\tcolor:yellow;</span><br><span class=\"line\">\tbackground:currentColor; //这里currentColor就是yellow</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//同样的</span><br><span class=\"line\">.box&#123;</span><br><span class=\"line\">\tcolor:yellow;</span><br><span class=\"line\">\t.inner-box&#123;</span><br><span class=\"line\">\t\tbackground:currentColor;//文字颜色继承而来，所以这里的currentColor也是yellow</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有，border和box-shadow的默认值都是currentColor，也就是说，这两个属性不设置颜色值时默认采用currentColor,比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\tcolor:yellow;</span><br><span class=\"line\">\tborder:1px solid;//等同于  border:1px solid yellow;</span><br><span class=\"line\">\tbox-shadow:0 0 0;//等同于 box-shadow:0 0 0 yellow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["技术","web前端","css"],"tags":["css"]},{"title":"python3快速入门","url":"/2022/04/05/python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","content":"<h5 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h5><p>有一定的编程基础，入门一门高级编程语言其实不难，但是要达到”出神入化”的使用效果，还是得下一番功夫并且经过大量的代码锤炼。话不多说，本文主要通过精炼简洁的描述呈现如何入门python3这门语言，至于一些更深层次或边界问题，会在后续关于python3的文章中有所涉及。</p>\n<h5 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h5><p>python是一种结合了解释性、编译性、互动性和面向对象的脚本语言。它的特点是可移植、可拓展、可嵌入，强面向对象。</p>\n<h5 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h5><p>#单行注释</p>\n<p>‘’’或者“”“多行注释</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#单行注释</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">多行注释</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">这也是多行注释</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"行和缩进\"><a href=\"#行和缩进\" class=\"headerlink\" title=\"行和缩进\"></a>行和缩进</h5><p>python的特点就是利用缩进表示代码块。同一个代码块的语句必须包含相同的缩进空格数，否则报错。</p>\n<h5 id=\"多行语句\"><a href=\"#多行语句\" class=\"headerlink\" title=\"多行语句\"></a>多行语句</h5><p>python通过反斜杠来实现多行语句</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">str</span> = str1 +\\</span><br><span class=\"line\">\t  str2 +\\</span><br><span class=\"line\">      str3</span><br></pre></td></tr></table></figure>\n\n<p>如果在[],{},（）中，多行语句不需要使用反斜杠</p>\n<h5 id=\"空行\"><a href=\"#空行\" class=\"headerlink\" title=\"空行\"></a>空行</h5><p>空行一般用于分割不同功能或涵义的代码，使其更加方便维护和重构。</p>\n<h5 id=\"用户输入\"><a href=\"#用户输入\" class=\"headerlink\" title=\"用户输入\"></a>用户输入</h5><p>input函数可以接受用户输入</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">str</span> = <span class=\"built_in\">input</span>(<span class=\"string\">&#x27;请输入 然后按回车键&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">str</span>)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"模块导入\"><a href=\"#模块导入\" class=\"headerlink\" title=\"模块导入\"></a>模块导入</h5><p>将整个模块导入，格式为：<code>import module_name</code></p>\n<p>从某个模块中导入某个函数,格式为：<code>from module_name import func1</code></p>\n<p>从某个模块中导入多个函数,格式为：<code>from module_name import func1, func2, func3</code></p>\n<p>将某个模块中的全部函数导入，格式为：<code>from module_name import *</code></p>\n<h5 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h5><p>变量必须在使用前声明好，不然会报错</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">name = <span class=\"string\">&#x27;Brian&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(name)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h5><p>1、布尔类型</p>\n<p>只有True和False,用来表示真和假</p>\n<p>2、数字类型</p>\n<p>包括整型、浮点型、复数</p>\n<ul>\n<li>不同类型的数字混合运算时会将整数转换为浮点数</li>\n<li>在不同的机器上浮点运算的结果可能会不一样</li>\n<li>在整数除法中，除法 <code>/</code> 总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 <code>//</code>。</li>\n<li><code>//</code> 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系</li>\n<li>在交互模式中，最后被输出的表达式结果被赋值给变量 <code>_</code>，<code>_</code> 是个只读变量</li>\n</ul>\n<p>常见的数学函数</p>\n<p>abs、fabs、ceil、floor、</p>\n","categories":["技术","python"],"tags":["python","入门"]},{"title":"写点什么","url":"/2020/01/05/%E5%86%99%E7%82%B9%E4%BB%80%E4%B9%88/","content":"<p>工作以来，我是”踩在巨人的肩膀”上成长的。</p>\n<p>不管是专家们的书籍还是行业大佬的博客，每每阅读，总能让自己受益匪浅。</p>\n<p>作为互联网开源思想的受益者，也总想着是否可以做出一点贡献，闲暇时写一些技术类的文章，为后来者指点迷津。</p>\n<p>但是，总感觉自己技术还不够硬，不敢误人子弟，也就迟迟没有行动。</p>\n<p>继续作为一个“伸手党”，把”拿来主义“奉行到底。</p>\n<p>时间一长，总感觉羞愧丢人。</p>\n<p>遂，下定决心，在不断加强相关技术认知的同时，抽空写一写技术博客，分享自己的学习历程。</p>\n<p>如果可能，给予阅读者一丁点”答疑解惑”</p>\n<p>或可聊以慰藉。</p>\n","categories":["随感"],"tags":["起点"]},{"title":"css奇技淫巧之all","url":"/2021/12/05/css%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%E4%B9%8Ball/","content":"<h5 id=\"all属性\"><a href=\"#all属性\" class=\"headerlink\" title=\"all属性\"></a>all属性</h5><p>all属性将除unicode-bidi和direction之外的所有属性重置为其初始值或继承的值。属性值有initial、inherit和unset。</p>\n<p>下面用代码说明<br> <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> //html</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;div class=&#x27;container&#x27;&gt;123&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//css</span><br><span class=\"line\">body&#123;</span><br><span class=\"line\">\tcolor:blue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.container&#123;</span><br><span class=\"line\">\tcolor:red;</span><br><span class=\"line\">\tall:inherit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> 得到的结果将会是</p>\n<p> <img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://s1.328888.xyz/2022/04/09/XOmiF.png\"\n                      alt=\"XOmiF.png\"\n                ></p>\n<p> 如果把all设置为initial，将会得到一个初始值</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://s1.328888.xyz/2022/04/09/XO3Zy.png\"\n                      alt=\"XO3Zy.png\"\n                ></p>\n<p>如果all:unset,则表示，如果可继承，则将应用于元素或元素父元素的所有属性更改为其父值，否则将其更改为初始值。</p>\n","categories":["技术","web前端","css"],"tags":["css"]},{"title":"css奇技淫巧之background-clip","url":"/2021/09/05/css%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%E4%B9%8Bbackground-clip/","content":"<p>这是一个有趣的属性，它让我们可以为元素的背景设置自定义图形。</p>\n<p>我们的自定义图形可以延伸到元素的边框，内边距盒或内容盒。</p>\n<p>看看代码实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p class=&quot;border-box&quot;&gt;背景延伸到边框。&lt;/p&gt;</span><br><span class=\"line\">&lt;p class=&quot;padding-box&quot;&gt;背景延伸到边框的内部边缘。&lt;/p&gt;</span><br><span class=\"line\">&lt;p class=&quot;content-box&quot;&gt;背景仅延伸到内容盒的边缘。&lt;/p&gt;</span><br><span class=\"line\">&lt;p class=&quot;text&quot;&gt;背景被裁剪为前景文本。&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<p>css部分：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">p &#123;</span><br><span class=\"line\">    border: .8em darkviolet;</span><br><span class=\"line\">    border-style: dotted double;</span><br><span class=\"line\">    margin: 1em 0;</span><br><span class=\"line\">    padding: 1.4em;</span><br><span class=\"line\">    background: linear-gradient(60deg, red, yellow, red, yellow, red);</span><br><span class=\"line\">    font: 900 1.2em sans-serif;</span><br><span class=\"line\">    text-decoration: underline;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.border-box &#123;</span><br><span class=\"line\">    background-clip: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.padding-box &#123;</span><br><span class=\"line\">    background-clip: padding-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.content-box &#123;</span><br><span class=\"line\">    background-clip: content-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.text &#123;</span><br><span class=\"line\">    background-clip: text;</span><br><span class=\"line\">    -webkit-background-clip: text;</span><br><span class=\"line\">    color: rgba(0, 0, 0, .2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终得到的效果</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://s1.328888.xyz/2022/04/09/Xnhtk.png\"\n                      alt=\"Xnhtk.png\"\n                ></p>\n","categories":["技术","web前端","css"],"tags":["css"]},{"title":"css奇技淫巧之writing-mode","url":"/2021/03/05/css%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%E4%B9%8Bwriting-mode/","content":"<p>writing-mode用来定义文本在水平或者垂直方向上如何排布，控制文本的展示方向。</p>\n<p>属性值：</p>\n<ul>\n<li><p>horizontal-tb：水平方向自上而下的书写方式。即 left-right-top-bottom</p>\n</li>\n<li><p>vertical-rl：垂直方向自右而左的书写方式。即 top-bottom-right-left</p>\n</li>\n<li><p>vertical-lr：垂直方向内内容从上到下，水平方向从左到右</p>\n</li>\n<li><p>sideways-rl：内容垂直方向从上到下排列</p>\n</li>\n<li><p>sideways-lr：内容垂直方向从下到上排列</p>\n</li>\n</ul>\n<p>MDN Web的具体描述：</p>\n<p> <img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://s1.328888.xyz/2022/04/09/XnXN0.png\"\n                      alt=\"XnXN0.png\"\n                ></p>\n","categories":["技术","web前端","css"],"tags":["css"]},{"title":"javascript之闭包","url":"/2021/04/09/javascript%E4%B9%8B%E9%97%AD%E5%8C%85/","content":"<p>javascript中闭包是一个很重要的概念，它有三个特点：</p>\n<ul>\n<li>函数嵌套函数</li>\n<li>函数内部可以引用外部的参数和变量</li>\n<li>参数和变量不会被垃圾回收机制回收</li>\n</ul>\n<p>闭包一般用来设计私有的方法和变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function aaa() &#123;  \t</span><br><span class=\"line\">    var a = 1;  \t\t</span><br><span class=\"line\">    return function()&#123;\t\t</span><br><span class=\"line\">        alert(a++)\t</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var fun = aaa();</span><br><span class=\"line\">fun();// 1 执行后 a++，，然后a还在</span><br><span class=\"line\">fun();// 2   </span><br><span class=\"line\">fun = null;//a被回收！！</span><br></pre></td></tr></table></figure>\n<p>闭包的好处是，使得一个变量长期驻留在内存，避免全局变量的污染。但是，正是由于常驻内存，会增大内存使用量，处理不当就会造成内存泄漏。</p>\n<p>看下面这段代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function add () &#123;  </span><br><span class=\"line\">    var test = 0;  </span><br><span class=\"line\">    return function () &#123;    </span><br><span class=\"line\">        test++;    </span><br><span class=\"line\">        return test;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var test = add();</span><br><span class=\"line\">console.log(test()); // 1</span><br><span class=\"line\">console.log(test()); // 2</span><br><span class=\"line\">console.log(test()); // 3</span><br><span class=\"line\">console.log(test()); // 4</span><br><span class=\"line\">console.log(test()); // 5</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>闭包保持对test的引用，除非手动清除，否则它会常驻内存。</p>\n","categories":["技术","web前端"],"tags":["javascript"]},{"title":"javascript之原型","url":"/2021/06/10/javascript%E4%B9%8B%E5%8E%9F%E5%9E%8B/","content":"","categories":["技术","web前端","javascript"],"tags":["javascript","js"]}]