<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="个人博客">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Brian">
    
    <title>
        
            前端知识问答 |
        
        oops
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/avatar.png">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"pointwong.github.io","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#ef5b00","avatar":"/images/avatar.png","favicon":"/images/avatar.png","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"山中何事？松花酿酒，春水煎茶"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}},"shadow":"#ccc"},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":false,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                oops
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               target="_blank" rel="noopener" href="https://benbb.cc"
                            >
                                BENBB
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       target="_blank" rel="noopener" href="https://benbb.cc">BENBB</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">前端知识问答</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Brian</span>
                        
                            <span class="author-label">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-04-02 12:39:06</span>
        <span class="mobile">2022-04-02 12:39</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/web%E5%89%8D%E7%AB%AF/">web前端</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p><strong>link标签的行内属性 deffer和async的含义和区别</strong></p>
<p>当script标签设置这两个行内属性后，js文件将会异步加载，不会阻塞dom的渲染。</p>
<p>它们的区别是：defer会在endanger渲染完成后DOMContentLoaded之前按照顺序执行。而async只要加载完就会立即执行</p>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p><strong>移动端的适配</strong></p>
<p>参考 <a class="link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/b13d811a6a76" >https://www.jianshu.com/p/b13d811a6a76<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>sass&#x2F;less&#x2F;stylus如何实现主题切换</strong></p>
<p>基本的思路：把不同主题的样式代码打包在一起，通过不同的主题class来实现主题切换。这个class可以加载body上或者根组件上，也可以加载到具体的元素或者更小的模块上。</p>
<p>下面看看sass的实现</p>
<p>首先，创建一个theme.scss文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$light&#123;</span><br><span class="line">	primaryColor:white;</span><br><span class="line">&#125;;</span><br><span class="line">$dark&#123;</span><br><span class="line">	primaryColor:black;</span><br><span class="line">&#125;</span><br><span class="line">$themes:&#123;</span><br><span class="line">	light:$light,</span><br><span class="line">	dark:$dark</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建一个themify.scss</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@import &#x27;./theme.scss&#x27;</span><br><span class="line">@mixin themify($themes:$themes)&#123;</span><br><span class="line">	@each $them-name,$theme-map in $themes &#123;</span><br><span class="line">		$theme-map:$theme-map !global //局部变量提升为全局变量</span><br><span class="line">		body[data-theme=#&#123;$theme-name&#125;] &amp; &#123;</span><br><span class="line">			@content;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">@function themed($key)&#123;</span><br><span class="line">	@return map-get($theme-map,$key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@import &#x27;/themify.scss&#x27;</span><br><span class="line">.container&#123;</span><br><span class="line">	@include themify($themes)&#123;</span><br><span class="line">		color:themed(&#x27;primaryColor&#x27;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现一个三栏布局</strong></p>
<p>三栏布局有很多种方法：利用绝对定位、浮动、bfc，flex、table等都可以实现</p>
<p>具体可参考 <a class="link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25070186" >https://zhuanlan.zhihu.com/p/25070186<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>哪些css属性会自动继承，哪些不会？具体讲讲</strong></p>
<p>字体、文本、可见性属性(opacity visibility)等大多是自动继承属性；盒子模型、背景、定位、生成内容(如content)、轮廓等一般是无继承属性。需要注意：a标签的字体颜色不能被继承，h1-h6的字体大小也不能被继承。</p>
<p><strong>什么是bfc</strong></p>
<p>bfc即块级格式化上下文，它会形成相对于其容器外一个独立的空间，其内部的子元素不会影响到外部的元素，同时不会和float的元素重叠。bfc可应用于防止margin坍塌、实现多栏布局、清除浮动等场景。触发bfc的条件&#x2F;属性：html、float、值不为visible的overflow、display为inline-block、table、inline-table、table-cell、table-caption、flex、inline-flex、grid、inline-grid.</p>
<h3 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h3><p><strong>普通函数和箭头函数的区别</strong></p>
<ul>
<li>箭头函数没有arguments绑定，取而代之用rest参数…解决。但是，箭头函数可以访问最近的非箭头函数的arguments对象。</li>
<li>箭头函数没有自己的this，它的this在生命周期中是保持不变的，始终与最近的非箭头函数中的this的值绑定。</li>
<li>箭头函数不能作为构造函数，也就是不能被new，</li>
<li>箭头函数不能存在重复命名的参数</li>
<li>箭头函数没有原型属性</li>
<li>箭头函数不能当做Generator函数，不能使用yield关键字</li>
</ul>
<p><strong>weakSet和weakMap的应用场景</strong></p>
<ul>
<li>weakSet的成员只能是对象，不能是其他类型。weakSet中的对象都是弱引用，因此垃圾回收机制不考虑weakSet对该对象的引用，如果其他对象不再引用该对象，垃圾回收机制将会自动回收该对象所占用的内存，而不考虑该对象还存在于weakSet中。使用场景：用来存储dom节点，而不用担心这些节点从文档移除会引发内存泄露。</li>
<li>weakMap只能接受对象作为键名，不接受其他类型的值作为键名。weakMap同样不会妨碍垃圾回收机制。</li>
<li>使用场景：在网页的dom元素上添加数据，就可以使用weakMap结构，当该dom元素被清除，其对应的weakMap记录会被自动移除。</li>
</ul>
<p><strong>js如何比较两个对象是否相等</strong></p>
<p>通过遍历一层一层比较值是否相等，当前层遇到对象，则继续遍历，直到最深一层的值为基本类型。</p>
<p><strong>es6的继承</strong></p>
<p>extends</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// es6继承</span><br><span class="line">  class Animal &#123;</span><br><span class="line">    //构造函数，里面写上对象的属性</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">      this.name = props.name || &#x27;Unknown&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    //方法写在后面</span><br><span class="line">    eat() &#123;//父类共有的方法</span><br><span class="line">      console.log(this.name + &quot; will eat pests.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //class继承</span><br><span class="line">  class Bird extends Animal &#123;</span><br><span class="line">    //构造函数</span><br><span class="line">    constructor(props,myAttribute) &#123;//props是继承过来的属性，myAttribute是自己的属性</span><br><span class="line">      //调用实现父类的构造函数</span><br><span class="line">      super(props)//相当于获得父类的this指向</span><br><span class="line">      this.type = props.type || &quot;Unknown&quot;;//父类的属性，也可写在父类中</span><br><span class="line">      this.attr = myAttribute;//自己的私有属性</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fly() &#123;//自己私有的方法</span><br><span class="line">      console.log(this.name + &quot; are friendly to people.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    myattr() &#123;//自己私有的方法</span><br><span class="line">      console.log(this.type+&#x27;---&#x27;+this.attr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//通过new实例化</span><br><span class="line">  var myBird = new Bird(&#123;</span><br><span class="line">    name: &#x27;小燕子&#x27;,</span><br><span class="line">    type: &#x27;Egg animal&#x27;//卵生动物</span><br><span class="line">  &#125;,&#x27;Bird class&#x27;)</span><br><span class="line">  myBird.eat()</span><br><span class="line">  myBird.fly()</span><br><span class="line">  myBird.myattr()</span><br></pre></td></tr></table></figure>

<p><strong>object.assign和…拓展符的区别</strong></p>
<p>本质上没有区别，object.assign等同于…拓展符。</p>
<p><strong>谈谈promise</strong></p>
<p>Promise是一种比较常用的异步编程方案。它有三种状态：</p>
<p>pending，fulfiled，rejected，分别表示等待，完成，失败。状态的改变只有两种pending-&gt;fulfiled,pending-&gt;rejected,这个过程是不可逆的。创建一个Promise实例时需要传入一个函数，这个函数的入参分别是resolve和reject两个函数，用来修改promise的状态。执行resolve后状态为fulfiled，执行reject后状态改为rejected，举个常见的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const p1= new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">	setTimeout(()=&gt;&#123;</span><br><span class="line">		if(isGood)&#123;</span><br><span class="line">			resolve(&#x27;成功了&#x27;)</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			reject(&#x27;失败了&#x27;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后通过链式调用的方式去处理状态变更后的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1.then(res=&gt;&#123;dosth&#125;)</span><br><span class="line">.catch(err=&gt;&#123;dosth&#125;)</span><br><span class="line">.finally(data=&gt;&#123;dosth&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise还提供了一些静态方法，用于做一些其他有趣的处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([p1,p2,p3,...])</span><br></pre></td></tr></table></figure>

<p>该方法接受一个promise组成的数组,所有的promise对象都成功才会触发fulfiled，只要有一个失败就会触发rejected</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.allSettled([p1,p2,p3,...])</span><br></pre></td></tr></table></figure>

<p>只要所有的promise都settled(fulfiled或rejected)，返回一个promise，携带一个对象数组，每个对象对应各个promise的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.race([p1,p2,p3,...])</span><br></pre></td></tr></table></figure>

<p>返回一个promise，只要有一个promise的状态改为fulfiled或rejected，则立即触发其自身的fulfied或者rejected。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(value)</span><br></pre></td></tr></table></figure>

<p>返回一个状态为成功的promise对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(error)</span><br></pre></td></tr></table></figure>

<p>返回一个状态为失败的promise对象。</p>
<p><strong>axios请求撤销，重连</strong></p>
<p>撤销主要是利用axios.CancelToken，axios官网介绍了两种使用方法：</p>
<p>方法一（多用于取消单个接口）：</p>
<p>通过传入一个执行函数到CancelToken构造函数来创建一个cancel token</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">let cancel</span><br><span class="line">export function getSth()&#123;</span><br><span class="line">	return axios(&#123;</span><br><span class="line">		url:&#x27;/abc&#x27;，</span><br><span class="line">		method:&#x27;get&#x27;.</span><br><span class="line">		cancelToken:new axios.CancelToken(funtion executor(c)&#123;</span><br><span class="line">			cancel = c</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要取消的时候，直接调用cancel即可</p>
<p>方法二（撤销多个请求）：</p>
<p>使用CancelToken.source工厂方法创建一个cancel token。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">const CancelToken = axios.CancelToken</span><br><span class="line">const source = CancelToken.source()</span><br><span class="line">export function getSth()&#123;</span><br><span class="line">	return axios(&#123;</span><br><span class="line">		url:&#x27;/abc&#x27;,</span><br><span class="line">		method:&#x27;get&#x27;,</span><br><span class="line">		cancelToken:source.token</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取消调用source.cancel()</p>
<p>关于重连，即网络出现不佳或者请求失败的重新连接机制。</p>
<p>axios的重连可通过响应拦截器来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">request.interceptors.response.use(</span><br><span class="line">	response =&gt;response.data || &#123;&#125;,</span><br><span class="line">	err =&gt;&#123;</span><br><span class="line">		let config = err.config</span><br><span class="line">		if(!config) return Promise.reject(err)</span><br><span class="line">		config._retryCount = config._retryCount || 0</span><br><span class="line">		//设置重连3次</span><br><span class="line">		if(config._retryCount&gt;3)return Promise.reject(err)</span><br><span class="line">		config.retryCount++</span><br><span class="line">		</span><br><span class="line">		//2s延迟发起新请求</span><br><span class="line">		let newReq= new Promise((rs)=&gt;&#123;</span><br><span class="line">			setTimeout(()=&gt;&#123;</span><br><span class="line">				rs()</span><br><span class="line">			&#125;,2000)</span><br><span class="line">		&#125;)</span><br><span class="line">		//返回新的axios请求</span><br><span class="line">		return newReq.then(function()&#123;</span><br><span class="line">			return request(config)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>说活对js&#x2F;node的事件循环机制</strong></p>
<p>这个问题出现频率还是挺高的，主要考察面试者对js这门语言认识的深度，理解它的执行机制。在github上已经有人回答得很具体了：</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://github.com/febobo/web-interview/issues/167" >说说对Nodejs中事件循环机制的理解<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://github.com/febobo/web-interview/issues/73" >说说你对事件循环的理解<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>new 具体做了什么，如何实现一个new？</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://github.com/febobo/web-interview/issues/69" >这是答案<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h3><p><strong>ts中函数重载的概念？应用场景？</strong></p>
<p>ts函数重载就是同一个函数提供多个函数类型，它的意义在于让你清晰的知道，传入不同的参数得到不同的结果，这也是它的应用场景。</p>
<h3 id="vue全家桶"><a href="#vue全家桶" class="headerlink" title="vue全家桶"></a>vue全家桶</h3><p><strong>vuex的原理，如何按需加载</strong></p>
<p>vuex是vuejs专用状态管理工具，采用集中式存储管理所有组件的状态，并保证状态以一种可预测的方式改变。</p>
<p>它由以下几个部分组成：</p>
<p><strong>state</strong></p>
<p>单一存储状态，存储基本数据</p>
<p><strong>getters</strong></p>
<p>是计算属性，类似vue实例中的computed</p>
<p><strong>mutations</strong></p>
<p>state的更改在这里处理</p>
<p><strong>actions</strong></p>
<p>提交mutation去更改数据，往往包含异步操作。</p>
<p><strong>module</strong></p>
<p>分割模块，每个模块拥有独立的state、getters、mutantions、actions</p>
<p>除此之外，vuex还提供了mapState,mapGetters.mapMutation,mapActions等函数，使得开发者在vm中更加方便地处理store.</p>
<p>vuex和vue实例绑定是借助mixin，在初始化阶段之前把store注册到vue组件实例，并注册引用$store。借助vue的data实现state的响应，借助computed实现getters的实时监听。</p>
<p>vuex按需加载，有时候我们进入首页，并不需要所有的vuex里面维护的状态，只需要加载首页用到的状态即可，这个时候就可以利用vuex提供的registerModule来按需异步加载不同的vuex模块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(isNeedVuexModule)&#123;</span><br><span class="line">	import(&#x27;./store/modules/&#x27;+moduleName).then(res=&gt;&#123;</span><br><span class="line">		this.$store.registerModule(moduleName,res.default)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>vue中是如何监听数组的改变的</strong></p>
<p>vue2在原因层面不支持用Object.defineProperty监听不存在的数组元素，并且通过一些能造成数组改变的方法也不能被监听到。vue2中重写了push，pop，shift，unshift，aplice.sort,reverse这七个数组方法，数组在执行这几个方法是手动触发响应页面的效果。至于为什么不去监听数组中已存在元素的变化，可参考：<a class="link"   target="_blank" rel="noopener" href="https://github.com/vuejs/vue/issues/8562" >https://github.com/vuejs/vue/issues/8562<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>谈谈vue.extend的作用</strong></p>
<p>Vue提供的一个构造器，用于创建一个子类，参数是一个包含组件选型的对象，</p>
<p>注意：Vue.extend创建的是一个构造器，而不是一个组件实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//html</span><br><span class="line">&lt;div id=&#x27;id&#x27;&gt;&lt;/div&gt;</span><br><span class="line">//js</span><br><span class="line">//创建构造器</span><br><span class="line">var Child = Vue.extend(&#123;</span><br><span class="line">	template:&#x27;&lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt;&#x27;,</span><br><span class="line">	data()&#123;</span><br><span class="line">		return&#123;</span><br><span class="line">			name:&#x27;Brian&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">new Child().$mount(&#x27;#id&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="前端架构"><a href="#前端架构" class="headerlink" title="前端架构"></a>前端架构</h3><p><strong>讲讲前端性能优化</strong></p>
<p>1、减少http请求</p>
<p>2、使用http2</p>
<p>3、使用服务端渲染</p>
<p>4、静态资源使用cdn</p>
<p>5、css放在文件头部，JavaScript放在文件底部，还有async和deffer的使用</p>
<p>6、使用字体图标代替图片图标</p>
<p>7、善用缓存，不重复加载相同的内容，cache-control, service worker</p>
<p>8、压缩文件</p>
<p>9、图片优化</p>
<ul>
<li>-图片延迟加载</li>
<li>-响应式图片，使用picture media</li>
<li>-调整图片大小</li>
<li>-降低图片质量</li>
<li>-尽可能利用css3效果代替图片</li>
<li>-使用webp格式的图片</li>
</ul>
<p>10、代码按需加载</p>
<p>11、减少页面重排重绘</p>
<ul>
<li>-修改样式时不直接写样式，而是通过替换class来改变样式</li>
<li>-先将dom元素脱离文档流，修改完之后再带回文档</li>
</ul>
<p>12、避免页面卡顿</p>
<p>目前大多数设备的屏幕刷新率为 60 次&#x2F;秒。因此，如果在页面中有一个动画或渐变效果，或者用户正在滚动页面，那么浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致。 其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒&#x2F; 60 &#x3D; 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。</p>
<p>13、使用requestAnimationFrame来实现视觉变化。</p>
<p>由于大部分设备刷新频率为60次&#x2F;秒，每一帧的平均时间大概为16毫秒，js实现动画最好的情况就是在帧的开头开始执行，requestAnimationFrame正好可以满足这点</p>
<p>14、使用webworker线程处理耗时操作</p>
<p><strong>说说微前端架构</strong></p>
<p>微前端其实是借鉴了微服务的概念，微服务大家都知道:后端(根据业务层次)分拆代码并形成独立的库，每个代码库负责自己的业务逻辑，并公开api，独立部署，分由不同团队维护。微前端借鉴了这种做法，把前端项目按照业务分拆成更小的单元，这些单元分由不同人员或团队开发维护，单独部署，其核心思想是远程应用程序和运行时加载。</p>
<p>参考 <a class="link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/414468874" >深入解析微前端乾坤原理<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="打包-x2F-构建工具"><a href="#打包-x2F-构建工具" class="headerlink" title="打包&#x2F;构建工具"></a>打包&#x2F;构建工具</h3><p><strong>关于webpack，如何编写一个loader和plugin</strong></p>
<p>1、关于loader</p>
<p>由于webpack只能处理js文件，对于其他类型的文件需要专门的转换器处理一下再传入webpack，这个转换器就是loader。它对模块的源代码进行转换，将文件从不同的语言转换为JavaScript，也可将图像转换为data URL。loader其实就是一个函数，接受源模块，把处理结果传给下一个loader或webpack。</p>
<p>下面来看看如何编写一个loader：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//一个把alert转为console.log的简单的loader</span><br><span class="line">/loaders/alertToConsole.js</span><br><span class="line">mudule.exports = function(source)&#123;</span><br><span class="line">	//source是webpack传入的源代码</span><br><span class="line">	return source.replace(&#x27;alert&#x27;,&#x27;console.log&#x27;)//把alert转为console.log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在webpack中配置该loader</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mudule:&#123;</span><br><span class="line">	rules:[</span><br><span class="line">		&#123;</span><br><span class="line">			test:/\.js/,</span><br><span class="line">			use:[</span><br><span class="line">				&#123;</span><br><span class="line">					loader:path.resolve(_dirname,&#x27;./loaders/alertToConsole.js&#x27;)</span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，项目中所有js文件中的alert就都会被转成console.log了。当然，如果要实现一些复杂的功能可能要先把源代码转为ast，也就是抽象语法树，可以将其看成树形js对象，通过遍历ast树可以做一些复杂的操作，最后再转化成目标代码返回。</p>
<p>2、关于plugin</p>
<p>webpack的生命周期中会广播出很多事件，plugin可以监听这些事件，在合适的时间通过webpack的api去改变输出结果。</p>
<p>一个简单的plugin的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class myPlugin&#123;</span><br><span class="line">	constructor(options)&#123;</span><br><span class="line">		console.log(&#x27;my plugin options&#x27;,options)</span><br><span class="line">	&#125;</span><br><span class="line">	apply(compiler)&#123;</span><br><span class="line">		compiler.plugin(&#x27;done&#x27;,compilation=&gt;&#123;</span><br><span class="line">			do something</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = myPlugin;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，可以把plugin看成带有apply方法的类。compiler代表webpack的整个生命周期，compilation代表依次新的编译过程。两者都暴露了钩子，可根据这些钩子编写一个满足实际需求的插件。</p>
<p>下面实现一个简单的需求：生成打包文件之后输出一个包含“文件打包完毕”的.txt文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/plugins/txtPlugin.js</span><br><span class="line">class txtPlugin&#123;</span><br><span class="line">	constructor(options)&#123;</span><br><span class="line">		this.options = options</span><br><span class="line">	&#125;</span><br><span class="line">	apply(compiler)&#123;</span><br><span class="line">		compiler.plugin(&#x27;done&#x27;,(compilation,callback)=&gt;&#123;</span><br><span class="line">			let words &#x27;文件打包完毕&#x27;</span><br><span class="line">			compilation.assets[&#x27;xxx.txt&#x27;]=&#123;</span><br><span class="line">				source:function()&#123;</span><br><span class="line">					return words</span><br><span class="line">				&#125;,</span><br><span class="line">				size:function()&#123;</span><br><span class="line">					return words.length</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			callback()</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = txtPlugin</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const txtPlugin = require(&#x27;/plugins/txtPlugin.js&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	plugins:[</span><br><span class="line">		new txtPlugin()</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、loader和plugin的区别</p>
<p>loader遵循单一原则，只能做一件事，比如sass-loader,只能解析sass&#x2F;scss文件,而plugin是针对整个流程的，在这个流程中可以广泛地执行任务。</p>
<h3 id="http-x2F-https"><a href="#http-x2F-https" class="headerlink" title="http&#x2F;https"></a>http&#x2F;https</h3><p><strong>http状态码</strong></p>
<p>常见的http状态码：</p>
<ul>
<li>1表示消息 100临时相应，需要客户端继续发送请求 101 服务器根据客户端请求切换协议 主要用于websoket或http2升级</li>
<li>2表示成功 200表示成功 201表示创建了新的资源 202 表示服务器已经接受了请求 但未处理 204服务器成功处理但不返回任何内容 206 表示处理了部分请求</li>
<li>表示重定向 301&#x2F;308永久重定向 302&#x2F;307临时 304表示使用缓存</li>
<li>4表示请求错误 400错误语法 401未授权 403服务器拒绝 404未找到 407需要代理 408超时</li>
<li>5表示服务器错误 500服务器内部错误 502网关错误 504网关超时 505 http版本的问题</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>路由&#x2F;按钮权限控制是怎么做的</strong></p>
<p>参考 <a class="link"   target="_blank" rel="noopener" href="https://juejin.cn/post/6844903933429678094" >https://juejin.cn/post/6844903933429678094<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>webapp如何做缓存</strong></p>
<p>serviceWorker,ApplicationCache ,LocalStorage,indexedDb</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：前端知识问答</li>
        <li>本文作者：Brian</li>
        <li>创建时间：2022-04-02 12:39:06</li>
        <li>
            本文链接：https://pointwong.github.io/2022/04/02/一些面试总结/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/web%E5%89%8D%E7%AB%AF/">#web前端</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/tags/%E9%9D%A2%E8%AF%95/">#面试</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/04/05/python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">python3快速入门</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/03/16/javascript%E4%B9%8B%E6%89%A7%E8%A1%8C%E6%A0%88/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">javascript之执行栈</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2023&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Brian</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML"><span class="nav-number">1.</span> <span class="nav-text">HTML</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS"><span class="nav-number">2.</span> <span class="nav-text">CSS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#javascript"><span class="nav-number">3.</span> <span class="nav-text">javascript</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#typescript"><span class="nav-number">4.</span> <span class="nav-text">typescript</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue%E5%85%A8%E5%AE%B6%E6%A1%B6"><span class="nav-number">5.</span> <span class="nav-text">vue全家桶</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84"><span class="nav-number">6.</span> <span class="nav-text">前端架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%8C%85-x2F-%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7"><span class="nav-number">7.</span> <span class="nav-text">打包&#x2F;构建工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http-x2F-https"><span class="nav-number">8.</span> <span class="nav-text">http&#x2F;https</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">9.</span> <span class="nav-text">其他</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>






    
<script src="/js/lazyload.js"></script>



<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
